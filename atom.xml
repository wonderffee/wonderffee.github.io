<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Wonderffee's Blog]]></title>
  <link href="http://wonderffee.github.io/atom.xml" rel="self"/>
  <link href="http://wonderffee.github.io/"/>
  <updated>2013-07-13T12:35:09+08:00</updated>
  <id>http://wonderffee.github.io/</id>
  <author>
    <name><![CDATA[wonderffee]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS抓包利器Charles]]></title>
    <link href="http://wonderffee.github.io/blog/2013/07/13/best-packet-capture-tool-charles-in-ios/"/>
    <updated>2013-07-13T11:21:00+08:00</updated>
    <id>http://wonderffee.github.io/blog/2013/07/13/best-packet-capture-tool-charles-in-ios</id>
    <content type="html"><![CDATA[<p>看唐巧的<a href="http://blog.devtang.com/blog/2013/06/23/alipay-plugin-mechanism/">分析支付宝客户端的插件机制</a>一文发现他使用了抓包工具Charles，想起去年有人给我推荐过这个工具，但是当时我觉得WireShark就够用了就没尝试。这次看到又有人使用Charles我就重视起来了，Charles到底有什么好？</p>

<p>搜了一下，发现大多数使用者都是将Charles作为移动端抓包工具使用的，这样就意味着我们可以用Charles来截取iPhone/iPad上app所发出的网络请求来进行分析，<a href="http://blog.devtang.com/blog/2013/06/23/alipay-plugin-mechanism/">分析支付宝客户端的插件机制</a>一文就是这么用的。WireShark显然做不到这一点，优势一下子就体现出来了。</p>

<!--more-->


<p>在Mac上安装Charles后，启动Charles，首先弹出一个框提示是否允许Charles有自动修改网络设置的权限，选择允许后出现Charles主界面。Charles主界面左侧有Structure和Sequence，你会发现会发现Structure这一栏里会逐步出现当前我的mac正在请求的链接，也就是说Charles一启动就自动进行抓包了。不过遗憾的是Structure栏里没有过滤选项，意味着你不能过滤特定网站。切换到Sequence栏，这个就容易懂了，按时间顺序来排列的，与WireShark一致。下方的Filter可以过滤，而是还是实时过滤的，这一点就比WireShark强多了。</p>

<p> <img src="http://wonderffee.github.io/images/Structure.png"></p>

<p> <img src="http://wonderffee.github.io/images/Sequence.png"></p>

<p>如何在Mac上用Charles远程抓iPhone上app的网络请求呢？方法相当简单，下面就提供了HTTP和HTTPS抓包的操作步骤，简单几步就搞定了。</p>

<h3>HTTP抓包</h3>

<ul>
<li>打开Charles程序</li>
<li>查看Mac电脑的IP地址，如192.168.1.7</li>
<li>打开iOS设置，进入当前wifi连接，设置HTTP代理Group，将服务器填为上一步中获得的IP，即192.168.1.7，端口填8888</li>
<li>iOS设备打开你要抓包的app进行网络操作</li>
<li>Charles弹出确认框，点击Allow按钮即可</li>
</ul>


<h3>HTTPS抓包</h3>

<ul>
<li>下载Charles证书<a href="http://www.charlesproxy.com/ssl.zip">http://www.charlesproxy.com/ssl.zip</a>，解压后导入到iOS设备中（将crt文件作为邮件附件发给自己，再在iOS设备中点击附件即可安装；也可上传至dropbox之类的网盘，通过safari下载安装）</li>
<li>在Charles的工具栏上点击设置按钮，选择Proxy Settings…</li>
<li>切换到SSL选项卡，选中Enable SSL Proxying，别急，选完先别关掉，还有下一步</li>
<li>这一步跟Fiddler不同，Fiddler安装证书后就可以抓HTTPS网址的包了，Charles则麻烦一些，需要在上一步的SSL选项卡的Locations表单填写要抓包的域名和端口，点击Add按钮，在弹出的表单中Host填写域名，比如填api.instagram.com，Port填443</li>
</ul>


<p>我简单试用了一下Charles的远程抓包功能，发现Charles比WireShark还有一个优势是能对JSON数据(在JSON Text栏)进行解析，从而让我们可以更直观地查看JSON串信息(在JSON 栏)。此外Charles对中文支持比较好，JSON串中的中文信息一般会显示为一长串的\ug开头的字符，解析之后就能显示出中文了。平常总头痛Wireshark对中文支持不好，用Charles就完全没有这个问题了。</p>

<p>参考资料： <br/>
<a href="http://larryhou.github.io/blog/2012/11/05/remote-debug-with-charles-proxy/">使用Charles远程调试iOS移动应用</a>   <br/>
<a href="http://ju.outofmemory.cn/entry/32837">mac下的抓包工具Charles</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS实现UIImageView透明区域点击事件穿透]]></title>
    <link href="http://wonderffee.github.io/blog/2013/07/10/pass-touch-event-through-uiimageviews-transparent-area-in-ios/"/>
    <updated>2013-07-10T22:16:00+08:00</updated>
    <id>http://wonderffee.github.io/blog/2013/07/10/pass-touch-event-through-uiimageviews-transparent-area-in-ios</id>
    <content type="html"><![CDATA[<h2>问题</h2>

<p>最近要在iPad上实现一个很独特的功能，简单描述一下就是要显示一个带有半透明背景的弹出界面，在其上加一个不规则形状的图片，手指点击这个弹出界面的半透明区域就退出这个弹出界面。</p>

<p>问题是UED/美工不会提供纯粹的不规则形状切图，实际只能给出的是以不规则形状加透明区域的矩形切图，这就带来另外一个要求：点击矩形切图的透明区域也要退出弹出界面。这就有点难办了，透明区域也是不规则形状的，该怎么判断出手指点击的点就是透明区域呢？</p>

<!--more-->


<h2>思路</h2>

<p>一般在iOS的控件中，要不就是完全允许用户点击，要不就是禁止用户交互，这是可以通过设置控件的userInteractionEnabled属性来修改。如果添加的图片不是不规则形状的，而是矩形，这问题就简单多了，只需要将矩形图片对应的UIImageView的userInteractionEnabled设为YES，对半透明背景View（或者直接设置为一个按钮）设置点击事件处理，就可以点击实现半透明背景退出弹出界面。</p>

<p>现在的情况是这个矩形图片一分为二，一部分为实体的不规则形状图片，一部分为不规则形状的透明区域。很显然，问题的解决思路是：让手指能“穿透”这个不规则透明区域去点击背后的半透明背景，而不透明部分就不“穿透”。</p>

<p>前面说的userInteractionEnabled属性只是简单地一刀切设置控件是否允许用户操作（即可以响应手指触摸事件），更加灵活的设置方法是使用UIView的hitTest:withEvent:与pointInside:withEvent:。简单介绍下，iOS中的pointInside:withEvent:方法是用来判断当前的点击或者触摸事件的点是否在当前的view中，它被hitTest:withEvent:调用，通过对每个子视图调用pointInside:withEvent:决定最终哪个视图来响应此事件。如果一个子视图的pointInside:withEvent:返回NO，说明这个子视图不会响应点击事件，然后就去寻找更深层的子视图来找到最终响应触摸事件；返回YES就说明子视图能响应点击事件（但不一定是子视图本身响应，若子视图还有子视图的话，还会继续循环去找最终响应事件的子子视图）。</p>

<p>于是，本文的问题就可以这样转化：创建一个UIImageView的子类，重写pointInside:withEvent:方法，让矩形图片的透明区域的pointInside:withEvent:返回NO，而非透明区域的pointInside:withEvent:返回YES，如果能达到这个要求，透明区域点击事件穿透就能够实现。</p>

<p>现在的关键问题是怎么识别出这个透明区域。 <br/>
iOS中通常用的图片是PNG图片，这种图片有alpha通道，如果能获取PNG图片每个像素的alpha值，就不难判断出手指点击的图片区域是不是透明的。</p>

<p>关键代码如下：</p>

<figure class='code'><figcaption><span>Here&#8217;s Code </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">pointInside:</span><span class="p">(</span><span class="n">CGPoint</span><span class="p">)</span><span class="nv">point</span> <span class="nf">withEvent:</span><span class="p">(</span><span class="n">UIEvent</span> <span class="o">*</span><span class="p">)</span><span class="nv">event</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">//Using code from http://stackoverflow.com/questions/1042830/retrieving-a-pixel-alpha-value-for-a-uiimage</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">pixel</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span><span class='line'>    <span class="n">CGContextRef</span> <span class="n">context</span> <span class="o">=</span> <span class="n">CGBitmapContextCreate</span><span class="p">(</span><span class="n">pixel</span><span class="p">,</span>
</span><span class='line'>                                                 <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
</span><span class='line'>                                                 <span class="n">kCGImageAlphaOnly</span><span class="p">);</span>
</span><span class='line'>    <span class="n">UIGraphicsPushContext</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
</span><span class='line'>    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">image</span> <span class="nl">drawAtPoint:</span><span class="n">CGPointMake</span><span class="p">(</span><span class="o">-</span><span class="n">point</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="n">point</span><span class="p">.</span><span class="n">y</span><span class="p">)];</span>
</span><span class='line'>    <span class="n">UIGraphicsPopContext</span><span class="p">();</span>
</span><span class='line'>    <span class="n">CGContextRelease</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">alpha</span> <span class="o">=</span> <span class="n">pixel</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mf">255.0f</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">BOOL</span> <span class="n">transparent</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">&lt;</span> <span class="mf">0.01f</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="o">!</span><span class="n">transparent</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>解释：  <br/>
这段代码是通过CGBitmapContextCreate方法创建只包含alpha通道的图形上下文（真不知道context怎么翻译为最好），这个图形上下文的大小为1x1，也就是实际上只放得下一个像素，将矩形图片手指触摸点point绘制到这个图形上下文中，那么pixel数组中唯一元素的值就是手指触摸点那一个像素的alpha值，做归一化为与0.01比较，如果小于0.01就表明手指触摸点是透明的，这时候返回NO就能够实现穿透效果，相反大于0.01就不会穿透。</p>

<p>注意到代码中用到的坐标为(-point.x, -point.y)，为什么会是负数呢？这是因为如果context的区域大小与image一致的话，[image drawAtPoint:]就会将image全部绘制在context中，而实际上context只放得下一个像素，为了保证point点能刚好绘制在这个context上，就必须设置绘制的起始坐标为(-point.x, -point.y)。</p>

<p>代码中的UIGraphicsPushContext容易误导人，看名字以为是将参数中指定的context push入栈，但是参数中的context明明就是刚创建的啊？其实它是将旧的context（默认的context）入栈，再切换到新的context（也就是参数中指定的）绘制，执行UIGraphicsPopContext后就会切换回旧的context，而在新的context上绘制的内容完全不影响旧context（默认context）。这与CGContextSaveGState和CGContextRestoreGState是有本质区别的。</p>

<p>附CGBitmapContextCreate函数参数详解: <br/>
原型：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">CGContextRef</span> <span class="nf">CGBitmapContextCreate</span> <span class="p">(</span>
</span><span class='line'>   <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
</span><span class='line'>   <span class="kt">size_t</span> <span class="n">width</span><span class="p">,</span>
</span><span class='line'>   <span class="kt">size_t</span> <span class="n">height</span><span class="p">,</span>
</span><span class='line'>   <span class="kt">size_t</span> <span class="n">bitsPerComponent</span><span class="p">,</span>
</span><span class='line'>   <span class="kt">size_t</span> <span class="n">bytesPerRow</span><span class="p">,</span>
</span><span class='line'>   <span class="n">CGColorSpaceRef</span> <span class="n">colorspace</span><span class="p">,</span>
</span><span class='line'>   <span class="n">CGBitmapInfo</span> <span class="n">bitmapInfo</span>
</span><span class='line'><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>参数：  <br/>
data                                    指向要渲染的绘制内存的地址。这个内存块的大小至少是（bytesPerRow*height）个字节 <br/>
width                                  bitmap的宽度,单位为像素 <br/>
height                                bitmap的高度,单位为像素  <br/>
bitsPerComponent        内存中像素的每个组件的位数.例如，对于32位像素格式和RGB 颜色空间，你应该将这个值设为8.  <br/>
bytesPerRow                  bitmap的每一行在内存所占的比特数  <br/>
colorspace                      bitmap上下文使用的颜色空间。  <br/>
bitmapInfo                       指定bitmap是否包含alpha通道，像素中alpha通道的相对位置，像素组件是整形还是浮点型等信息的字符串。</p>

<p>描述： <br/>
当你调用这个函数的时候，Quartz创建一个位图绘制环境，也就是位图上下文。当你向上下文中绘制信息时，Quartz把你要绘制的信息作为位图数据绘制到指定的内存块。一个新的位图上下文的像素格式由三个参数决定：每个组件的位数，颜色空间，alpha选项。alpha值决定了绘制像素的透明性。</p>

<h3>参考资料：</h3>

<ul>
<li><a href="http://blog.csdn.net/wangyuchun_799/article/details/7804809">CGBitmapContextCreate函数参数详解</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_489ab04e01010utb.html">UiView事件传递相关函数：pointInside:withEvent:</a></li>
<li><a href="http://wiki.eoe.cn/page/iOS_pptl_artile_28218.html">iOS中管理图形上下文</a></li>
<li><a href="http://stackoverflow.com/questions/13291919/detect-touches-only-on-non-transparent-pixels-of-uiimageview-efficiently">Detect touches only on non-transparent pixels of UIImageView, efficiently</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[搭建基于Github的Octopress博客]]></title>
    <link href="http://wonderffee.github.io/blog/2013/07/09/da-jian-ji-yu-githubde-octopressbo-ke/"/>
    <updated>2013-07-09T23:18:00+08:00</updated>
    <id>http://wonderffee.github.io/blog/2013/07/09/da-jian-ji-yu-githubde-octopressbo-ke</id>
    <content type="html"><![CDATA[<p>我无意像其它人一样写一个大而全的教程，这样的教程在网上已经有很多，你只需要参考下面任何一个教程都可以得到满意的答案。</p>

<ul>
<li><a href="http://octopress.org/docs/">Octopress官方文档</a></li>
<li><a href="http://blog.devtang.com/blog/2012/02/10/setup-blog-based-on-github/">象写程序一样写博客：搭建基于github的博客</a></li>
<li><a href="http://biaobiaoqi.me/blog/2013/03/21/building-octopress-in-github-mac/">在github上搭建octopress博客</a></li>
<li><a href="http://easypi.github.io/blog/2013/01/05/using-octopress-to-setup-blog-on-github/">利用Octopress在github Pages上搭建个人博客</a></li>
<li><a href="http://ishalou.com/blog/2012/10/15/how-to-use-octopress/">使用Octopress + Github管理blog</a>    <br/>
其中前面三个链接是我主要参考的。</li>
</ul>


<p>这里，我主要想记录我遇到的一些问题，以期望能对那些遇到类似问题的人有些许帮助。当然，如果你在操作之前先看到了这篇文章，那也不妨先看看再更有底气地动手。</p>

<!--more-->


<h3>Github repository设置</h3>

<p>基于Github的博客其实是利用了Github Pages支持html上传的功能来实现的，那么怎么开通Github Pages呢？答案很简单，在你的Github上创建一个名为username.github.io的repository，然后上传html就可以了。上传hmtl就是后面提到的rake deploy命令负责的，先不用管，这里说说repository的命名。</p>

<p>多数教程建议在GitHub上建立名为username.Github.com的repository（其中username要替换成Github真实用户名），但是我根据Octopress教程操作时，发现要求提供的Git地址是git@github.com:username/username.github.io.git，当时我就迷惑了，到底是.com还是.io？之后才发现.com这个后缀是Github早期推荐使用的，现在推荐使用.io格式，为了兼容起见，Github还是让username.github.com能够访问，不过是让它自动指向username.github.io而已。因此为了避免疑惑，对初次使用者还是建议使用username.github.io来命名自己的repository.</p>

<p>如果你还是一位Git初学者，在建repositionary时最好不要勾选生成README.md文件，说来惭愧，由于本人对Git还停留在准入门阶段，一时手贱结果让这个东东在后面给我造成了一些麻烦。如果你是Git初学者就信我这一回，不要勾选。</p>

<h3>Ruby安装失败问题</h3>

<p>准备条件中有一条要有ruby 1.9.3环境，我的MacOS系统(10.8.1)原生自带ruby，就是版本是1.8.7低了一点，需要通过rvm来升级到1.9.3版本。需要注意的是ruby现在已经是2.0版本了，不确定用最新版本的ruby能否安装成功，因此不要贸然尝试将ruby更新到最新版本。</p>

<p>我下载rvm后安装ruby 1.9.3，执行命令：rvm install 1.9.3，遇到下面的问题 <br/>
There was an error while trying to resolve rubygems version for &lsquo;latest&rsquo;.   <br/>
Halting the installation.   <br/>
不明原因，解决方法是重试：rvm reinstall 1.9.3   <br/>
参考：<a href="http://misheska.com/blog/2013/06/16/using-rvm-to-manage-multiple-versions-of-ruby/">http://misheska.com/blog/2013/06/16/using-rvm-to-manage-multiple-versions-of-ruby/</a></p>

<h3>Github SSH key</h3>

<p>Octopress博客的创建过程中需要用到Github SSH key，生成Github SSH key的方法可以参考Github官方的<a href="https://help.github.com/articles/generating-ssh-keys">Generating SSH Keys</a>教程</p>

<h3>访问博客时显示404的问题</h3>

<p>我按照别人博客教程里提供的方法弄完了，去看我的博客，发现给了一个404的页面。有人说要等十几分钟才会正常，结果我等了一个多小时还是原样。是怎么回事呢，最后才发现我漏输了一个&#8221;rake deploy&#8221;命令，导致我的本地博客根本就没有发布到Github上去，真是大意。</p>

<p>这还得从名为username.github.io的repository的构成说起，每个在Github上发布成功的博客，在username.github.io这个repository里都会有两个分支，分别为master和source。其中master分支存放博客正常显示所需要的静态文件（也就是rake generate生成的），source分支下是整个博客的全部源码。&#8221;rake deploy&#8221;命令的主要作用就是把本地的_deploy目录下面的内容push到远程的master分支，如果忘记执行这条命令，master分支下就没有内容，访问博客自然也就会出现404错误了。</p>

<h3>关于博客配置与MarkDown学习</h3>

<p>Github博客的配置主要在_config.yml这个文件中进行，各个教程也都做了简短介绍，比如去掉一些不用的侧边栏，增加分享与评论功能，但仅限于此。</p>

<p>在Github上写博客，MarkDown是必须的技能。基本上每个提供搭建Github博客教程都会让你去看MarkDown的语法教程或的网上介绍文章，比如<a href="http://daringfireball.net/projects/markdown/">这个</a>，还有<a href="http://wowubuntu.com/markdown/index.html">这个</a>。</p>

<p>但是我想说最好的教程就是各位大牛自己的博客，怎么说呢，基于Github建立的博客源码都是托管在Github上面的，我们完全可以找到每篇博客的源码。如果你想看看别人的博客是怎么配置的，可以去看他的博客源码souce分支下的_config.yml文件，如果想看别人的博客用MarkDown怎么写的，可以看source分支source目录下的_posts路径下的MarkDown文件，这比看各种各样的教程与介绍直观多了，而且很快能找到自己想要的。比如可以参考<a href="http://blog.devtang.com/">唐巧的博客</a>与对应的<a href="https://github.com/tangqiaoboy/tangqiaoboy.github.com">源码托管处</a>，看看他的博客怎么配置的、文章是怎么用MarkDown写出来的，然后自己照葫芦画瓢就行了。</p>

<p>编辑md文件我是用Sublime Text2的，供参考。</p>

<h3>发表博文常用命令：</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>#创建一篇博文
</span><span class='line'>rake new_post["post title"] #将在工作目录的source/_post/目录下生成相应的markdown文件。然后可以使用mou工具去修改编辑内容。
</span><span class='line'>
</span><span class='line'>#生成预览
</span><span class='line'>rake preview #可以在浏览器中访问localhost:4000在本机实时观察最新的编辑效果。
</span><span class='line'>
</span><span class='line'>#在线发布
</span><span class='line'>rake deploy  #这一步将最新的内容push到Github上的master分支，完成部署。成功后，即可在线访问。
</span><span class='line'>
</span><span class='line'>#向github提交源文件更新
</span><span class='line'>git add .
</span><span class='line'>git commit -m "提交内容"
</span><span class='line'>git push origin source
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>相对于其它博客，搭建这样的博客还是有点折腾的，费了我不少时间，还好对于我来说不是多大的问题。对于普通用户而言，恐怕就没那么简单了，技术门槛摆在那里是个问题。这种门槛也并非是坏事，至少将一些别有用心的人挡在了Github外面，SourceForge是前车之鉴啊。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[新的开始]]></title>
    <link href="http://wonderffee.github.io/blog/2013/07/06/a-new-begin/"/>
    <updated>2013-07-06T22:24:00+08:00</updated>
    <id>http://wonderffee.github.io/blog/2013/07/06/a-new-begin</id>
    <content type="html"><![CDATA[<p><img src="http://wonderffee.github.io/images/snail.jpg"></p>

<p>很久都没有写博客了，上一次写博客还是两三年前的事，那时还在学校，那时还没有现在这么忙。工作至今，越来越觉得有必要重新拣起博客，一些技术积累，一些心得，不记下来，永远只是在脑海中昙花一现。好记性不如烂笔头，这是亘古不变的真理。平常也会用EverNote来记录一些工作技术上的心得，但这种独自享有的感觉却并不好，现在的世界是开源的世界，我曾经索取很多，现在是时候再分享一些东西了。</p>

<!--more-->


<p>原来的博客是在博客大巴上的，在这个略有文艺清新风格的博客上写一些技术博客，感觉是有点不伦不类的，也没有氛围，再继续写下去，自己也不能接受。考虑过CSDN，但自己不太喜欢它的博客风格，我还是更喜欢能自定义一些东西。也想过用WordPress搭建自己的博客，可看到VPS的价格觉得自己是承受不起的，作罢。后来有一次搜资料搜到了唐巧的博客，觉得这种类苹果的简洁风格挺不错，一查个究竟，发现居然是在Github上建的博客，当时就惊诧了，神马，Github上也能写博客？看过那篇《象写程序一样写博客：搭建基于github的博客》什么都明白了，开源再次发挥了强大的力量。这种像Hacker一样的写博客也挺合我胃口，而且还可以把它当独立博客。接着，我在上周利用周末折腾了一下将博客基本搭出来了。那真的就是一时的冲动，坦白地说，那时候Git都不怎么会用，对Git的概念也还处于懵懵懂懂的状态，折腾的过程中因为不熟悉Git没少浪费时间。不过麻烦归麻烦，好处却少不了，至少开始正儿八经地用上Git了，以后也可以号称自己会用Git了，哈哈。</p>

<p>博客折腾完了，得开始给这个博客加点内容了。本人iOS攻城狮一枚，因此可以负责任说，这个博客以后的文章主打iOS开发技术了，当然也不排除写一些MLinux、Windows上的东西。本来自己一开始也不是做iOS开发的，后来机缘巧合才做起了这个。我工作一开始是用Linux C，做这个不到一年后因项目变动不得不从零起步做起了iOS开发，开始了天天与Mac、iPhone，iPad打交道的日子，看上去很让人羡慕，其实也不然。时间倒退几年，苹果的产品对我还是很遥远的东西，听闻Mac很漂亮，iPod很流行，iPhone更是风靡全球，但价格也是高高在上，当时还是学生的我也甭指望能用到苹果的任何东东了，当然，也没机会接触。因为工作的关系，我的系统使用完成了Windows&mdash;>Linux&mdash;>MacOS的大转变，第一次看到MacOS系统时，心里顿生一种惊艳的感觉，这直接导致我在接触iOS不到一年后就自己买了一台Mac Mini做为自己的主力用机，现在的这篇博客就是在这台小巧玲珑的东东上敲出来的。现在除了一些不可替代的软件，基本上都不用Windows了，自己的Windows笔记本也经常性地蒙上一尘灰。用Mac就基本上不用担心Windows上一些流氓软件了，杀毒软件也免了，跟Linux同源又比Linux漂亮，能有的软件也都有了，因此如果不是非Windows不可以及经济允许的话，我建议每个人都可以尝试一下Mac电脑，入门级，首选Mac Mini。貌似扯得有点远了。</p>

<p>其实，还是因为做iOS的缘故，让我认识了Github，很多iOS开源代码就放在Github上，不用还真不行，但用就是对的。iOS完全被苹果掌控，每年都会更新换代，这就意味着每一个iOS开发人员都得跟得上苹果的步伐才不至于落后，除了苹果的英文资料与网上的博客，Github上的代码就是最好的学习范例。就目前看来，Github上提供了世界最完美的编程社交平台，参与其中，必会有一些收获。打算以后，也要在Github上多多贡献自己一些代码了，要不然还真愧对于自己一直以来只求索取的行为了。</p>

<p>无论怎样，不管是用Github写博客还是在Github上贡献代码，对于自己来说都是新的尝试。自己需要做的，就是像一只蜗牛一样，缓缓前行，一步一步留下自己的印记！</p>

<p>本文图片来源：<a href="http://share.9ikblog.com/archives/30-tips-to-improve-your-ios-design-workflow-in-photoshop.html">PHOTOSHOP中改进IOS设计流程的30个诀窍</a></p>
]]></content>
  </entry>
  
</feed>
