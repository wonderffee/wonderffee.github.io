<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | Wonderffee's Blog]]></title>
  <link href="http://wonderffee.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://wonderffee.github.io/"/>
  <updated>2013-10-16T20:42:54+08:00</updated>
  <id>http://wonderffee.github.io/</id>
  <author>
    <name><![CDATA[wonderffee]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[通过实例来理解position与anchorPoint]]></title>
    <link href="http://wonderffee.github.io/blog/2013/10/14/understand-anchorpoint-and-position-with-instance/"/>
    <updated>2013-10-14T22:58:00+08:00</updated>
    <id>http://wonderffee.github.io/blog/2013/10/14/understand-anchorpoint-and-position-with-instance</id>
    <content type="html"><![CDATA[<p><a href="http://wonderffee.github.io/blog/2013/10/13/understand-anchorpoint-and-position/">上一篇文章</a>写了一些对position与anchorPoint的理解，这次就拿一些实例来加深印象。文中的例子来自别人的一篇<a href="http://www.cnblogs.com/yyh123/p/3345097.html">博文</a>，例子是不错的，但是自己刚开始也没完全搞明白，现在完全弄懂了，在这里借用一下并加以扩展，希望对看到的人有所帮助。</p>

<!--more-->


<p>先把之前的结论贴出来：<br/>
1、position是layer中的anchorPoint在superLayer中的位置坐标。<br/>
2、互不影响原则：单独修改position与anchorPoint中任何一个属性都不影响另一个属性。<br/>
3、frame、position与anchorPoint有以下关系：<br/>
{% codeblock lang:objc %}
frame.origin.x = position.x &ndash; anchorPoint.x * bounds.size.width；<br/>
frame.origin.y = position.y &ndash; anchorPoint.y * bounds.size.height；<br/>
{% endcodeblock %}</p>

<h3>1.创建一个CALayer，添加到控制器的view的layer中</h3>

<p>{% codeblock lang:objc %}
CALayer *myLayer = [CALayer layer];
// 设置层的宽度和高度（100x100）
myLayer.bounds = CGRectMake(0, 0, 100, 100);
// 设置层的位置
myLayer.position = CGPointMake(100, 100);
// 设置层的背景颜色：红色
myLayer.backgroundColor = [UIColor redColor].CGColor;</p>

<p>// 添加myLayer到控制器的view的layer中
[self.view.layer addSublayer:myLayer];
{% endcodeblock %}</p>

<p>第5行设置了myLayer的position为(100, 100)，又因为anchorPoint默认是(0.5, 0.5)，所以最后的效果是：myLayer的中点会在父层的(100, 100)位置。</p>

<p>My Note:根据anchorPoint默认为(0.5, 0.5)以及结论3中的的公式，可以得到frame.origin为(50, 50),所以myLayer在图中左上角的位置应为(50, 50)。见下图:</p>

<p>{% img /images/anchorPointInstance/1.png %}</p>

<h3>2.若将anchorPoint改为(0, 0)</h3>

<p>{% codeblock lang:objc %}
myLayer.anchorPoint = CGPointMake(0, 0);
{% endcodeblock %}</p>

<p>MyNote:根据结论2，修改anchorPoint不影响position，则frame.origin需要重新计算，如下：
{% codeblock lang:objc %}
frame.origin.x = 100 &ndash; 0 * 100 = 100;
frame.origin.y = 100 &ndash; 0 * 100 = 100;
{% endcodeblock %}
这样，myLayer的左上角就会就会移动到(100, 100)的位置。见下图：<br/>
{% img /images/anchorPointInstance/2.png %}</p>

<h3>3.若将anchorPoint改为(1, 1)</h3>

<p>{% codeblock lang:objc %}
myLayer.anchorPoint = CGPointMake(1, 1);
{% endcodeblock %}</p>

<p>MyNote:同上，直接重新计算frame.origin，会得到frame.origin为(0, 0)，myLayer左上角移动到(0, 0)的位置，见图：<br/>
{% img /images/anchorPointInstance/3.png %}</p>

<h3>4.将anchorPoint改为(0, 1)</h3>

<p>{% codeblock lang:objc %}
myLayer.anchorPoint = CGPointMake(0, 1);
{% endcodeblock %}
MyNote:类似地，直接重新计算frame.origin，会得到frame.origin为(100, 0)，myLayer左上角移动到(100, 0)的位置，见图：  <br/>
{% img /images/anchorPointInstance/4.png %}</p>

<h3>5.设置frame与bounds的区别</h3>

<p>先看代码1：
{% codeblock lang:objc %}
CALayer *myLayer1 = [CALayer layer];
myLayer1.bounds = CGRectMake(0, 0, 100, 100);
myLayer1.anchorPoint = CGPointZero;
myLayer1.backgroundColor = [UIColor redColor].CGColor;
[self.view.layer addSublayer:myLayer1];
{% endcodeblock %}</p>

<p>再看代码2：
{% codeblock lang:objc %}
CALayer *myLayer2 = [CALayer layer];
myLayer2.frame = CGRectMake(0, 0, 100, 100);
myLayer2.anchorPoint = CGPointZero;
myLayer2.backgroundColor = [UIColor redColor].CGColor;
[self.view.layer addSublayer:myLayer2];
{% endcodeblock %}</p>

<p>区别在于第二行代码一个使用bounds,一个使用frame, 猜猜myLayer1和myLayer2左上角的位置会相同吗？</p>

<p>你可能觉得是相同的，但其实不同，myLayer1左上角在(0, 0)点，myLayer1却不是预期的(0, 0)点，而是在(50, 50)点，也就是例1中的图，为什么？有人可能还会说我明明想将myLayer2左上角放在原点，怎么就不是呢？</p>

<p>关键在于用的是frame。对于一个还没有superLayer的layer来说，position和anchorPoint都是有默认值的，分别为(0, 0)和(0.5, 0.5),如果对该layer设置了frame，因为anchorPoint还是保持默认值不会变化，只能是position随之变动。所以根据3中的公式，position的计算如下：
{% codeblock lang:objc %}
position.x = 0 + 0.5 * 100 = 50
position.y = 0 + 0.5 * 100 = 50
{% endcodeblock %}</p>

<p>position被确定为(50, 50)，接着在代码2中又修改anchorPoint为(0, 0), 这个时候不影响position的值，只能是frame.origin被修改，也就是变成下面的：
{% codeblock lang:objc %}
frame.origin.x = 50 &ndash; 0 * 100 = 50;
frame.origin.y = 50 &ndash; 0 * 100 = 50;
{% endcodeblock %}</p>

<p>所以对一个已经确定frame的layer来说，再修改anchorPoint就会修改layer的位置，如果只想修改anchorPoint而不改变layer的位置，就用代码1的方式来进行，或者把代码2中设置frame与anchorPoint的代码顺序调换一下，就能解决问题。</p>

<p>要记住的就是设置frame会隐式修改position，而默认的anchorPoint从来不会被隐式修改，只能被显式修改。</p>

<h4>参考</h4>

<ul>
<li><a href="http://www.cnblogs.com/yyh123/p/3345097.html">position和anchorPoint</a></li>
<li><a href="http://stackoverflow.com/questions/1968017/changing-my-calayers-anchorpoint-moves-the-view">Changing my CALayer&rsquo;s anchorPoint moves the view</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[彻底理解position与anchorPoint]]></title>
    <link href="http://wonderffee.github.io/blog/2013/10/13/understand-anchorpoint-and-position/"/>
    <updated>2013-10-13T11:10:00+08:00</updated>
    <id>http://wonderffee.github.io/blog/2013/10/13/understand-anchorpoint-and-position</id>
    <content type="html"><![CDATA[<h3>引言</h3>

<p>相信初接触到CALayer的人都会遇到以下几个问题： <br/>
为什么修改anchorPoint会移动layer的位置？<br/>
CALayer的position点是哪一点呢?<br/>
anchorPoint与position有什么关系？</p>

<!--more-->


<p>我也迷惑过，找过网上的教程，大部分都是复制粘贴的，有些是翻译的文章但很有问题，看得似懂非懂，还是自己写代码彻底弄懂了，做点笔记吧。</p>

<p>每一个UIView内部都默认关联着一个CALayer, UIView有frame、bounds和center三个属性，CALayer也有类似的属性，分别为frame、bounds、position、anchorPoint。frame和bounds比较好理解，bounds可以视为x坐标和y坐标都为0的frame，那position、anchorPoint是什么呢？先看看两者的原型，可知都是CGPoint点。</p>

<p>@property CGPoint position<br/>
@property CGPoint anchorPoint</p>

<h3>anchorPoint</h3>

<p>一般都是先介绍position，再介绍anchorPoint。我这里反过来，先来说说anchorPoint。</p>

<p>从一个例子开始入手吧，想象一下，把一张A4白纸用图钉订在书桌上，如果订得不是很紧的话，白纸就可以沿顺时针或逆时针方向围绕图钉旋转，这时候图钉就起着支点的作用。我们要解释的anchorPoint就相当于白纸上的图钉，它主要的作用就是用来作为变换的支点，旋转就是一种变换，类似的还有平移、缩放。</p>

<p>继续扩展，很明显，白纸的旋转形态随图钉的位置不同而不同，图钉订在白纸的正中间与左上角时分别造就了两种旋转形态，这是由图钉（anchorPoint）的位置决定的。如何衡量图钉（anchorPoint）在白纸中的位置呢？在iOS中，anchorPoint点的值是用一种相对bounds的比例值来确定的，在白纸的左上角、右下角，anchorPoint分为为(0,0), (1, 1)，也就是说anchorPoint是在单元坐标空间(同时也是左手坐标系)中定义的。类似地，可以得出在白纸的中心点、左下角和右上角的anchorPoint为(0.5,0.5), (0,1), (1,0)。</p>

<p>然后再来看下面两张图，注意图中分iOS与MacOS，因为两者的坐标系不相同，iOS使用左手坐标系，坐标原点在左上角，MacOS使用右手坐标系，原点在左下角，我们看iOS部分即可。
<img src="/images/anchorPointAndPosition/layer_coords_anchorpoint_position_2x.png" title="Optional title" alt="test" />  <br/>
图1</p>

<p><img src="/images/anchorPointAndPosition/anchorpoint2.jpg" title="Optional title" alt="test" />  <br/>
图2</p>

<p>像UIView有superView与subView的概念一样，CALayer也有superLayer与layer的概念，前面说到的白纸和图中的矩形可以理解为layer，书桌和图中矩形以外的坐标系可以理解成superLayer。如果各自以左上角为原点，则在图中有相对的两个坐标空间。</p>

<h3>position</h3>

<p>在图1中，anchorPoint有(0.5,0.5)和(0,0)两种情况，分别为矩形的中心点与原点。那么，这两个anchorPoint在superLayer中的实际位置分别为多少呢？简单计算一下就可以得到(100, 100)和(40, 60)，把这两个值分别与各自的position值比较，发现完全一致，该不会是巧合？</p>

<p>这时候可以大胆猜测一下，position是不是就是anchorPoint在superLayer中的位置呢？答案是确定的，更确切地说，position是layer中的anchorPoint点在superLayer中的位置坐标。因此可以说, position点是相对suerLayer的，anchorPoint点是相对layer的，两者是相对不同的坐标空间的一个重合点。</p>

<p>再来看看position的原始定义：
The layer’s position in its superlayer’s coordinate space。<br/>
中文可以理解成为position是layer相对superLayer坐标空间的位置，很显然，这里的位置是根据anchorPoint来确定的。</p>

<p>图2中是矩形沿不同的anchorPoint点旋转的形态，这就是类似于刚才讲的图钉订在白纸的正中间与左上角时分别造就了两种旋转形态。</p>

<h3>anchorPoint、position、frame</h3>

<p>anchorPoint的默认值为(0.5,0.5)，也就是anchorPoint默认在layer的中心点。默认情况下，使用addSublayer函数添加layer时，如果已知layer的frame值，根据上面的结论，那么position的值便可以用下面的公式计算：
<code>
position.x = frame.origin.x + 0.5 * bounds.size.width；  
position.y = frame.origin.y + 0.5 * bounds.size.height；  
</code></p>

<p>里面的0.5是因为anchorPoint取默认值，更通用的公式应该是下面的：<br/>
<code>
position.x = frame.origin.x + anchorPoint.x * bounds.size.width；  
position.y = frame.origin.y + anchorPoint.y * bounds.size.height；
</code></p>

<p>下面再来看另外两个问题，如果单方面修改layer的position位置，会对anchorPoint有什么影响呢？修改anchorPoint又如何影响position呢？  <br/>
根据代码测试，两者互不影响，受影响的只会是frame.origin，也就是layer坐标原点相对superLayer会有所改变。换句话说，frame.origin由position和anchorPoint共同决定，上面的公式可以变换成下面这样的：<br/>
<code>
frame.origin.x = position.x - anchorPoint.x * bounds.size.width；  
frame.origin.y = position.y - anchorPoint.y * bounds.size.height；
</code></p>

<p>这就解释了为什么修改anchorPoint会移动layer，因为position不受影响，只能是frame.origin做相应的改变，因而会移动layer。</p>

<h3>理解与运用</h3>

<p>在Apple doc对frame的描述中有这么一句话：</p>

<blockquote><p>Layers have an implicit frame that is a function of the position, bounds, anchorPoint, and transform properties.</p></blockquote>

<p>可以看到我们推导的公式基本符合这段描述，只不过还缺少了transform，加上transform的话就比较复杂，这里就不展开讲了。</p>

<hr />

<p>Apple doc中还有一句描述是这样的：</p>

<blockquote><p>When you specify the frame of a layer, position is set relative to the anchor point. When you specify the position of the layer, bounds is set relative to the anchor point.</p></blockquote>

<p>大意是：当你设置图层的frame属性的时候，position根据锚点（anchorPoint）的值来确定，而当你设置图层的position属性的时候，bounds会根据锚点(anchorPoint)来确定。</p>

<p>这段翻译的上半句根据前面的公式容易理解，后半句可能就有点令人迷惑了，当修改position时，bounds的width与height会随之修改吗？其实,position是点，bounds是矩形，根据锚点(anchorPoint)来确定的只是它们的位置，而不是内部属性。所以，上面这段英文这么翻译就容易理解了：</p>

<blockquote><p>当你设置图层的frame属性的时候，position点的位置（也就是position坐标）根据锚点（anchorPoint）的值来确定，而当你设置图层的position属性的时候，bounds的位置（也就是frame的orgin坐标）会根据锚点(anchorPoint)来确定。</p></blockquote>

<p>在实际情况中，可能还有这样一种需求，我需要修改anchorPoint，但又不想要移动layer也就是不想修改frame.origin，那么根据前面的公式，就需要position做相应地修改。简单地推导，可以得到下面的公式：
<code>  
positionNew.x = positionOld.x + (anchorPointNew.x - anchorPointOld.x)  * bounds.size.width  
positionNew.y = positionOld.y + (anchorPointNew.y - anchorPointOld.y)  * bounds.size.height
</code></p>

<p>但是在实际使用没必要这么麻烦。修改anchorPoint而不想移动layer，在修改anchorPoint后再重新设置一遍frame就可以达到目的，这时position就会自动进行相应的改变。写成函数就是下面这样的：
{% codeblock lang:objc %}
&ndash; (void) setAnchorPoint:(CGPoint)anchorpoint forView:(UIView *)view{</p>

<pre><code>CGRect oldFrame = view;
view.layer.anchorPoint = anchorpoint;
view.frame = oldFrame;
</code></pre>

<p>}
{% endcodeblock %}</p>

<h3>总结</h3>

<p>1、position是layer中的anchorPoint在superLayer中的位置坐标。<br/>
2、互不影响原则：单独修改position与anchorPoint中任何一个属性都不影响另一个属性。<br/>
3、frame、position与anchorPoint有以下关系：<br/>
<code>
frame.origin.x = position.x - anchorPoint.x * bounds.size.width；  
frame.origin.y = position.y - anchorPoint.y * bounds.size.height；
</code></p>

<p>第2条的互不影响原则还可以这样理解：position与anchorPoint是处于不同坐标空间中的重合点，修改重合点在一个坐标空间的位置不影响该重合点在另一个坐标空间中的位置。</p>

<h4>参考</h4>

<ul>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreAnimation_guide/CoreAnimationBasics/CoreAnimationBasics.html#//apple_ref/doc/uid/TP40004514-CH2-SW15">Core Animation Programming Guide</a></li>
<li><a href="http://stackoverflow.com/questions/1968017/changing-my-calayers-anchorpoint-moves-the-view">Changing my CALayer&rsquo;s anchorPoint moves the view</a></li>
<li><a href="http://www.cocoachina.com/bbs/simple/?t87118.html">对于anchorPoint的一点理解</a></li>
<li><a href="http://www.dreamingwish.com/dream-2012/coreanimation-programming-guide-10-kvc.html">CoreAnimation编程指南(十)KVC</a></li>
<li><a href="http://www.dreamingwish.com/dream-2012/coreanimation-programming-guide-c-the-geometric-transformation.html">CoreAnimation编程指南(三)几何变换</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[升级iOS7后利用rvictl和wireshark抓包失效?]]></title>
    <link href="http://wonderffee.github.io/blog/2013/10/06/caputure-packets-with-rvictl-and-wireshark-after-updating-to-ios7/"/>
    <updated>2013-10-06T11:31:00+08:00</updated>
    <id>http://wonderffee.github.io/blog/2013/10/06/caputure-packets-with-rvictl-and-wireshark-after-updating-to-ios7</id>
    <content type="html"><![CDATA[<p>最近把一台设备升级到iOS7后，利用rvictl和wireshark抓包发现抓不了，无意中发现在装有xcode5的机器上可以抓包，看来rvictl与xcode是绑定的，升级到最新的iOS7后，必须要装上最新的xcode5版本才能抓包。</p>

<p>使用rvictl有一个前提是要获取设备的UDID，看网上不少教程都是从xcode中获取UDID，步骤相当繁琐，快速获取UDID用命令行才是王道，果然不出所料，很快就找到了三种命令行快速得到iOS设备的UDID方法，如下：</p>

<!--more-->


<p>方法1：速度最快
{% codeblock lang:bash %}
ioreg -w 0 -rc IOUSBDevice -k SupportsIPhoneOS | sed -n &rsquo;s/.<em>USB Serial Number[^0-9a-z]</em>([0-9a-z]<em>).</em>/\1/p'
{% endcodeblock %}</p>

<p>方法2：不知道为什么不起作用了，因为iOS7的缘故？
{% codeblock lang:bash %}
system_profiler SPUSBDataType | sed -n -e &lsquo;/iPhone/,/Serial/p&rsquo; | grep &ldquo;Serial Number:&rdquo; | awk -F &ldquo;: &rdquo; &lsquo;{print $2}&rsquo;
{% endcodeblock %}</p>

<p>方法3:
{% codeblock lang:bash %}
system_profiler SPUSBDataType | grep &ldquo;Serial Number:.<em>&rdquo; | sed s#&ldquo;.</em>Serial Number: &rdquo;##
{% endcodeblock %}</p>

<p>不过注意的是，用上面的命令得到的UDID并不一定是唯一的，比如我在MacBook Pro上就得不到唯一的UDID。</p>

<p>以下转载一下用rvictl和wireshark进行抓包的方法：</p>

<p>RVI(Remote Virtual Interface）是在iOS5中开始添加的，利用这个工具，在不需要开代理，也不需要越狱的情况下就可以抓到iOS设备上所有的包，所需要的一台装有Mac OS X的电脑以及USB数据线。我发现Android还没有类似的工具，iOS在这方面就方便多了。</p>

<p>基本的方法就是把设备通过USB连上mac上。然后为这台设备安装RVI，这个虚拟的在Mac上的网卡，就代表这台ios设备的使用网卡。然后在mac上跑抓包的工具，定位到这个虚拟的网卡上，来抓包。</p>

<p>(1)安装RVI，需要使用rvictl工具，以下步骤在mac的终端中操作：  <br/>
{% codeblock lang:bash %}
$ # First get the current list of interfaces.
$ ifconfig -l
lo0 gif0 stf0 en0 en1 p2p0 fw0 ppp0 utun0
$ # Then run the tool with the UDID of the device.</p>

<p>$ rvictl -s 74bd53c647548234ddcef0ee3abee616005051ed
Starting device 74bd53c647548234ddcef0ee3abee616005051ed [SUCCEEDED]</p>

<p>$ # Get the list of interfaces again, and you can see the new virtual
$ # network interface, rvi0, added by the previous command.
$ ifconfig -l
lo0 gif0 stf0 en0 en1 p2p0 fw0 ppp0 utun0 rvi0
{% endcodeblock %}</p>

<p>(2)安装成功后，此时其实可以用任何抓包工具来抓取。包括wireshark等。因为这时就会看到一个rvi0的网卡。不过今天我们介绍的是通过tcpdump来搞。</p>

<p>在终端中输入如下命令：
{% codeblock lang:bash %}
sudo tcpdump -i rvi0 -n -s 0 -w dump.pcap tcp
{% endcodeblock %}</p>

<p>解释一下上面重要参数的含义：</p>

<p>-i rvi0 选择需要抓取的接口为rvi0（远程虚拟接口）  <br/>
-s 0 抓取全部数据包  <br/>
-w dump.pcap 设置保存的文件名称  <br/>
tcp 只抓取tcp包</p>

<p>当tcpdump运行之后，你可以在iOS设备上开始浏览你想抓取的App，期间产生的数据包均会保存到dump.pcap文件中，当想结束抓取时直接终止tcpdump即可。然后在mac中找到dump.pcap文件。用wireshark打开就ok。</p>

<p>(3)去掉RVI这个虚拟网卡，使用下面的命令： <br/>
{% codeblock lang:bash %}
$ rvictl -x 74bd53c647548234ddcef0ee3abee616005051ed  <br/>
Stopping device 74bd53c647548234ddcef0ee3abee616005051ed [SUCCEEDED] <br/>
{% endcodeblock %}</p>

<p>整个流程就是这样的。自己动手操作一下吧。。</p>

<p>再详细的细节，请找一下苹果官方的资料：Technical Q&amp;A QA1176。</p>

<p>参考链接：  <br/>
<a href="http://blog.csdn.net/hursing/article/details/8688868">Mac上命令行获取iPhone/iPad的Identifier（UUID） 的方法</a>  <br/>
<a href="http://b.imi.im/post/121">一行命令 得到iOS设备的UDID</a>  <br/>
<a href="http://fanliugen.com/?p=351">未越狱ios设备的抓包方法</a></p>
]]></content>
  </entry>
  
</feed>
