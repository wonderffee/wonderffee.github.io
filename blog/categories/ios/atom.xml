<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | Wonderffee's Blog]]></title>
  <link href="http://wonderffee.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://wonderffee.github.io/"/>
  <updated>2015-06-04T23:32:40+08:00</updated>
  <id>http://wonderffee.github.io/</id>
  <author>
    <name><![CDATA[wonderffee]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[利用QuincyKit + KSCrash构建自己的Crash Log收集与管理系统]]></title>
    <link href="http://wonderffee.github.io/blog/2014/07/19/quincykit-and-kscrash/"/>
    <updated>2014-07-19T10:37:00+08:00</updated>
    <id>http://wonderffee.github.io/blog/2014/07/19/quincykit-and-kscrash</id>
    <content type="html"><![CDATA[<p>其实早就想写这篇文章了，我去年的<a href="http://wonderffee.github.io/blog/2013/08/14/dont-use-symbolicatecrash-to-symbolicate-the-crash-log/">一篇文章</a>就提到了QunicyKit，一直拖到现在，再不写一年就过去了。</p>

<!--more-->


<h3>前言</h3>

<p>我们知道，iOS bug定位是极看重crash log的，目前网上提供了不少crash log收集与管理服务，较有名的有Crashlytics, Flurry, 友盟，可能大部分人也就是使用这个。我这里要说的QuincyKit + KSCrash是一对开源组合，可能没有前者各种高大上的功能，基本功能还是有的，但更偏重于以下使用场合：</p>

<p>1）访问外网不太方便，或者大部分情况下在内网测试  <br/>
2）对出现的crash问题要求快速响应，快速定位   <br/>
3）需要自己掌控Crash Report，而不是交给别人</p>

<p>显而易见，第1条就足以把Crashlytics, Flurry, 友盟诸如此类的排除在外了；        <br/>
关于第2条，我所知道的Flurry显示crash report延迟比较大，至少为6小时，Crashlytics稍微好一些，但是它们的服务器在国外，网页打开也比较慢。这里要额外说的是比较讨厌Crashlytics在程序每次编译时都会上传app binary与dSYM文件，在网络情况较差或app比较大的情况下相当费时。
还有我经历的另一种情况，就是开发与测试人员相隔比较远，比如开发的在5楼，测试的在1楼，在最原始的阶段测试人员发现了崩溃问题，会将测试设备送到5楼让开发人员用Mac解析，想想这效率，不言自明了吧。   <br/>
第3点其实比较勉强，crash log又没多少机密可言。</p>

<h3>QuincyKit</h3>

<p>相信还是有一些人了解<a href="https://github.com/TheRealKerni/QuincyKit">QuincyKit</a>的，不过我看到相关的文章比较少。我之前主要参考的是Nico的<a href="http://www.taofengping.com/2012/12/08/quincykit_crashreport/#.U8PkSI2SzCE">《QuincyKit的crashReport框架》</a>和<a href="http://www.taofengping.com/2013/03/29/crash_again/#.U8PkSI2SzCE">《炒冷饭，再提一次QuincyKit》</a>.</p>

<p>QuincyKit，简而言之，是一个为iOS和Mac OS X提供的程序崩溃报告管理解决方案。关于QuincyKit的介绍大家看Nico的文章就了解得差不多了，它对测试期的应用来说确实是很方便的，不需要提前注册APP Key，不管你有多少个应用，App中集成了QuincyKit的Client端后，只管向Server端发送crash log就行，Server端会自动根据App ID来分类管理。</p>

<p>QuincyKit分Server端和Client端。它的Server端是用php编写的，用一个支持PHP5.2以上，还有Mysql、Apache的服务器就可以搭建起一个完整的环境，Mac/Linux/Windows系统上应该都可以完成。看似简单，实际上对从没搭建过服务器环境的初学者可能有点麻烦，不用担心，还有XAMPP这个神器来解决大部分麻烦。当初我图简单省事，就是用XAMPP来搭建基本环境的，不过相关的笔记找不到了，这里就没办法贴上了。</p>

<p>另外要说明一下，QuincyKit Server端的Web管理界面比较简陋，比如连按时间排序的功能都没有，不过既然是开源的，就不能要求太高，会PHP的完全可以尝试为自己订制更高级的功能。</p>

<h3>KSCrash</h3>

<p>这里要说的是我只使用了QuincyKit的Server端，Client端我选择了<a href="https://github.com/kstenerud/KSCrash">KSCrash</a>，可能有很多人对KSCrash对比较陌生，这也不奇怪，在国内就没见到有人介绍KSCrash。为什么是KSCrash呢，个中原因，且听我慢慢道来：</p>

<p>1）如果我没记错的话，QuincyKit client端生成的crash报告与原生crash报告相比总是缺少最关键的那一行，而KSCrash客户端生成的crash报告会把这关键的一行放在最后一行，并提供一些额外的信息，非常有利于问题定位。大部分情况下，我只看这最后一行就能定位到问题所在。  <br/>
2）QuincyKit在2013年初基本就停止更新了，而KSCrash目前仍旧是持续更新的，对于我们来说最重要是Client端的更新，比如考虑未来支持Swift的可能性。而Server端主要是用来管理crash log，免费开源的QuincyKit足够对付使用。  <br/>
3）KSCrash客户端生成的crash报告在大部分情况下都不需要dSym符号文件你就可以看到函数名，问题比较明显的话很快就能得到定位。但是默认显示的行号还是不对的，如果需要具体行号，还得利用dSym符号文件解析crash报告才行。（这点似乎QuincyKit客户端也支持的）</p>

<p>最关键是第1点，我想会不会有人因为这放弃使用了QuincyKit。</p>

<p>需要注意的是，KSCrash只是一个Client端，本身是没有Server端的。但这也是它的灵活之处，因为它能对接免费的QuincyKit，收费的Hockey、Victory等Server端，也能将生成的crash log通过Email的方式发送。这只是KSCrash的特性之一，更多KSCrash的关键特性你可以看下面列举出来的，相信你能看到惊喜：</p>

<ul>
<li>支持设备上解析与离线重新解析</li>
<li>生成的报告格式完全兼容iOS原生crash报告格式</li>
<li>支持32位和64位模式（实验性质）</li>
<li>能处理mach level下的错误，例如堆栈溢出</li>
<li>侦测未能捕捉的C++异常的真实原因</li>
<li>侦测访问僵尸(zombie or deallocated)对象的行为</li>
<li>恢复僵尸对象或内存覆盖情况下NSException的异常信息</li>
<li>提取对象异常调用的有效信息（比如发生unrecognized selector sent to instance 0xa26d9a0异常的情况）</li>
<li>支持多种Server端，提供方便的API接口</li>
<li>显示堆栈内容</li>
<li>诊断崩溃原因</li>
<li>记录比Apple原生crash报告更多的信息，使用JSON格式储存</li>
<li>支持显示用户自定义的额外数据</li>
</ul>


<p>KSCrash能处理的crash分以下几种：</p>

<ul>
<li>Mach kernel 异常</li>
<li>Fatal signals</li>
<li>C++ 异常</li>
<li>Objective-C异常</li>
<li>主线程死锁 (实验性质)</li>
<li>自定义崩溃（脚本语言）</li>
</ul>


<p>经过我的测试，使用KSCrash目前主要有以下两个问题：    <br/>
1) 在部分情况下会造成死锁（deadlock）crash，这通常是应用在做比较耗时的操作时出现的，如果发生这样的问题，你应该尽量优化你的APP，避免耗时操作（可能是我打开了死锁检测的功能，目前这个功能是Unstable Features）   <br/>
2) 如果发生crash后重启应用时收集crash报告的服务器不可达，则之前的crash报告就会被废弃，即使重新恢复网络，仍然不会重新发送。</p>

<p>如果有人介意这些问题，可以尝试自行修改KSCrash的开源代码达到自己的目的。</p>

<p>需要说明的是，App发布时，还是建议大家使用Flurry、Crashlytics或者友盟，毕竟你面对的可能是数以万计甚至更多的用户。你可以在你的应用中增加一个开关，测试期打开开关使用KSCrash上报crash log，发布前关闭开关，使用Crashlytics或其它在线crash report工具。万万要记得在自己的checklist里加上一条开关状态核对，以免忘记。</p>

<h3>Crash Log自动解析</h3>

<p>关于QuincyKit还有一个解析端，或者说是Mac端，因为crash log的解析是必须在Mac上进行的。要解析QuincyKit Server端收集到的crash log，就必须在解析端的Mac电脑上执行一个symbolicate.php脚本。它做的事情实际上就是将QuincyKit上未解析过的crash log下载到本地，批量进行解析，然后再批量上传回去。你可以启动一个定时任务定时去执行这个脚本，就不用每次都手动执行了。</p>

<p>但是有一个问题，如果你想每次都能解析成功，你的Mac上需要提前拥有与crash log对应的.app文件、.app.dSYM文件的索引。这个索引可以通过mdimport命令来实现（mdimport的介绍可参考<a href="http://wonderffee.github.io/blog/2013/08/14/dont-use-symbolicatecrash-to-symbolicate-the-crash-log/">这里</a>）。不过肯定还是有人觉得手动执行mdimport命令进行索引挺麻烦的，最好的办法还是用脚本将各个流程串通起来自动化实现。</p>

<p>我能想到的一个自动化流程是：  <br/>
(1) 自动构建版本，生成ipa文件和dSYM.zip文件  <br/>
(2) 解析端通过脚本拿到ipa文件和dSYM.zip文件，然后copy到指定文件夹，解压，执行mdimport   <br/>
(3) 在解析端的Mac电脑上开启一个定时任务，定时执行symbolicate.php</p>

<p>经历这3步，就可以保证你在QuincyKit web网页上永远看到的是解析后的crash log。</p>

<p>做到了这一切，如果你经历过手动执行symbolicatecrash命令来解析crash log的阶段，就知道一个是天上，一个是地下了。</p>

<h3>后记</h3>

<p>原谅我没有贴图，因为我都是在公司里搭的系统，家里没有。在网上就找到一张QuincyKit的web管理界面，供参考</p>

<p><img src="/images/quincykit_web.jpg"></p>

<p>搜索资料时还有意外发现，《<a href="http://nielsmouthaan.nl/doutzen/">Doutzen: Local symbolication for QuincyKit</a>》一文的作者做了一个Mac应用来完成解析端的工作，将配置简单化，并实现了定时自动解析。不过根据评论，应该是不兼容Lion系统，估计更不会兼容最新的10.9/10.10了，好在代码是开源的，会Mac开发的稍作修改就可以拿来为己所用了。</p>

<p>还有人用Rails写了一个类QuincyKit的Server端，提供在线服务网站holdbug.com，但是代码好像不开源，网站也打不开了，估计是停止支持了，链接见<a href="http://ju.outofmemory.cn/entry/37054">这里</a>。</p>

<h3>参考：</h3>

<ul>
<li><a href="https://github.com/TheRealKerni/QuincyKit">QuincyKit</a></li>
<li><a href="https://github.com/kstenerud/KSCrash">KSCrash</a></li>
<li><a href="http://www.taofengping.com/2012/12/08/quincykit_crashreport/#.U8PkSI2SzCE">QuincyKit的crashReport框架</a></li>
<li><a href="http://www.taofengping.com/2013/03/29/crash_again/#.U8PkSI2SzCE">炒冷饭，再提一次QuincyKit</a></li>
<li><a href="http://www.jeremyfuller.net/the-battle-of-the-ios-crash-reporters/comment-page-1/">The battle of the iOS crash reporters</a></li>
<li><a href="http://nielsmouthaan.nl/doutzen/">Doutzen: Local symbolication for QuincyKit</a></li>
<li><a href="http://ju.outofmemory.cn/entry/37054">【开源】最近用 rails 做了一个 ios crash 的收集系统</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[unrecognized selector sent to instance问题之诱敌深入关门打狗解决办法]]></title>
    <link href="http://wonderffee.github.io/blog/2014/05/17/solve-unrecognized-selector-sent-to-instance-problem/"/>
    <updated>2014-05-17T11:03:00+08:00</updated>
    <id>http://wonderffee.github.io/blog/2014/05/17/solve-unrecognized-selector-sent-to-instance-problem</id>
    <content type="html"><![CDATA[<p>前不久在微博上看到一篇文章，<a href="http://blog.objcc.com/unrecognized-selector-sent-to-instance/">《UNRECOGNIZED SELECTOR SENT TO INSTANCE 问题快速定位的方法》</a> 其中讲了iOS unrecognized selector sent to instance问题的快速定位方法，方法是不错的，但是实际测试发现文中的方法并非万能，从我自身的经历以及文中的评论看都有不能解决的情况。</p>

<!--more-->


<p>出现unrecognized selector sent to instance问题，大部分是因为对象被提前释放，指针变成野指针，还有一种情况是本身就是野指针，如声明一个局部对象，没有初始化就直接调用。定位难的原因是你知道这个野指针指到哪个类了，但是不知道是哪里产生了野指针。如果一个正常的对象调用一个不存在的方法，也会给出这个提示，不过这种情况下Xcode会直接给出crash的代码行，不存在定位难的问题。</p>

<p>我遇到这个问题的情况是这样的：写的代码一直在iOS7下进行调试，运行得好好的，最近想测试一下iOS6的兼容性，结果登录成功后就会产生crash，提示[NewsViewController size] unrecognized selector sent to instance，看到这个问题当时真是相当莫名其妙，NewsViewController无论如何都不可能有size这个方法，是什么让NewsViewController调用这个方法呢？</p>

<p>在Xcode中用size关键词搜索所有调用size的地方一个个排除？别逗了，代码里多的是。想象一下，你在iOS7下写好了全部代码，然后在iOS6下测试兼容性时出现此问题，面对茫茫如海的代码，足够让你望洋兴叹了，一个个去找，费不起那功夫。</p>

<p>想起来上面那篇文章中的方法，结果是毫无帮助，下断点无效。</p>

<p>只得再另想办法。要快速定位问题代码行，主要思路还是得下断点，还有没有别的办法下断点呢？这个时候可就要在“unrecognized selector sent to instance”的提示上做文章了，这个提示的实际意义是某个对象调用了不存在的方法。不妨逆向思考一下，既然它没有，我如果给它加上一个呢？这不下断点的机会就来了——所谓诱敌深入，关门打狗，不过如此。</p>

<p>于是，我就在NewsViewController中加了一个这样的方法：
<code>objc
- (CGSize)size{
NSLog(@"test");
return CGSizeZero;
}
</code>
在其中的NSLog行加上断点，运行工程，果然就找到了调用该方法的代码行，问题迎刃而解。</p>

<p>出错的代码也贴一下吧，简化一下大概就是下面这样的:
<code>objc
- (void)test{
UIImage *imgNormal, *imgSelected;
NSLog(@"imagNormal width is %f", imgNormal.size.width);
}
</code></p>

<p>问题出在NSLog的那一行，很显然，这就是没有初始化的局部对象在实际访问时出错，系统认为它是NewsViewController对象， 不再属于UIImage类了。</p>

<p>需要注意的是，上面的代码你拿过去并不一定能复现同样的问题，可能就不会发生crash了。这里只是提供另一种解决思路，希望对遇到此问题的人有所帮助。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 3D UI——CALayer的transform扩展解析]]></title>
    <link href="http://wonderffee.github.io/blog/2013/10/19/an-analysis-for-transform-samples-of-calayer/"/>
    <updated>2013-10-19T17:44:00+08:00</updated>
    <id>http://wonderffee.github.io/blog/2013/10/19/an-analysis-for-transform-samples-of-calayer</id>
    <content type="html"><![CDATA[<h3>引言</h3>

<p>这篇文章的主要内容来自于CocoaChina论坛上的一篇文章，只不过原文在有些地方介绍得不是很详细，我这里增加了一些解析，也算是自己做笔记，原文和代码均可以在这个链接里找到：<a href="http://www.cocoachina.com/bbs/read.php?tid=117061&amp;page=1">IOS 3D UI &mdash;&ndash; CALayer的transform扩展</a>。</p>

<!--more-->


<p>iOS的UI是基于UIView类的，我们能看到的每个UI元素都是UIView或者UIView的子类。View按树形结构组织起来，树根是UIWindow。</p>

<h3>UIView与CALayer</h3>

<p>View负责界面的交互和显示，其中显示部分由CALayer来完成。每个UIView包含一个CALayer实例。可以这么认为，UIView本身是不可见的，我们能看到的都是CALayer，UIView只是负责对CALayer进行管理。</p>

<p>UIView的显示设置都是对CALayer属性的封装，但是这层封装掩盖了CALayer提供的3D显示功能。所以我们想让UIView显示3D的效果的话，需要直接操作CALayer。</p>

<p>要操作CALayer对象，首先要在工程中包含QuartzCore.framework，在文件中import &lt;QuartzCore/QuartzCore.h>头文件。QuartzCore.framework中包含了CALayer以及CALayer一些官方子类的定义。</p>

<p>通过设置CALayer的transform属性，可以使CALayer产生3D空间内的平移、缩放、旋转等变化。</p>

<h3>绕坐标轴的旋转</h3>

<p>原始场景如图：</p>

<p><img src="/images/CALayerTransform/CALayerOrigin.png" alt="test" /></p>

<p>使用image.layer.transform = CATransform3DMakeRotation(M_PI/6, 0, 1, 0); 绕Y轴旋转30度后的效果:</p>

<p><img src="/images/CALayerTransform/CALayerRotation30y.png" alt="test" /></p>

<p>可以发现，绕Y轴旋转只是在X轴上进行了缩放，这是因为，在CALayer的显示系统中，默认的相机使用正交投影，正交投影没有远小近大效果，所以在本例中，只能造成相应轴上的缩放。在这种情况下，无论是绕Y轴旋转30度还是-30度都是同样的效果。</p>

<h3>透视投影</h3>

<p>CALayer默认使用正交投影，因此没有远小近大效果，而且没有明确的API可以使用透视投影矩阵。所幸可以通过矩阵连乘自己构造透视投影矩阵。构造透视投影矩阵的代码如下：
```objc</p>

<pre><code>CATransform3D CATransform3DMakePerspective(CGPoint center, float disZ)
{
    CATransform3D transToCenter = CATransform3DMakeTranslation(-center.x, -center.y, 0);
    CATransform3D transBack = CATransform3DMakeTranslation(center.x, center.y, 0);
    CATransform3D scale = CATransform3DIdentity;
    scale.m34 = -1.0f/disZ;
    return CATransform3DConcat(CATransform3DConcat(transToCenter, scale), transBack);
}

CATransform3D CATransform3DPerspect(CATransform3D t, CGPoint center, float disZ)
{ 
    return CATransform3DConcat(t, CATransform3DMakePerspective(center, disZ));
}
</code></pre>

<p>```</p>

<p>代码中，center指的是相机 的位置，相机的位置是相对于要进行变换的CALayer的来说的，原点是CALayer的anchorPoint在整个CALayer的位置，例如CALayer的大小是(320, 160), anchorPoint值为(0.5, 0.5)，此时anchorPoint在整个CALayer中的位置就是(160, 80)，正中心的位置。传入透视变换的相机位置为(0, 0)，那么相机所在的位置相对于CALayer就是(160, 80)。如果希望相机在左上角，则需要传入(-160, -80)。disZ表示的是相机离z=0平面（也可以理解为屏幕）的距离。</p>

<p>怎么解释这段代码呢？
第一步，layer在CATransform3DPerspect方法中首先进行了t变换，要注意的是这时候进行的t变换是以anchorPoint为中心点，默认情况下是在layer的中心位置。</p>

<p>第二步，在CATransform3DMakePerspective方法先进行了一个(-center.x, -center.y, 0)的平移，然后进行了透视投影，最后又做了一个(center.x, center.y, 0)平移。关键在于这两个反向的平移。
当center为(0,0)也就是相机中心在CALayer的中心位置，与anchorPoint(0.5, 0.5)重合时，平移的距离为0也就是没有做平移，这时候是直接把已经做过t变换的layer通过scale进行透视投影变换的。</p>

<p>当center不在中心位置时，假设在CALayer的左上角，那么center为(-160, -80)。那center就平移到了(0,0)点，等于把相机点又平移回到了与anchorPoint重合的这一点，但由于平移此时这个重合点成矩形图片的左上角了。那么为什么要平移至使相机点与anchorPoint点重合呢？</p>

<p>这里得明确一点，相机点与layer同时在X-Y平面上做相同的偏移时，因为没有改变z值，在相机点看到的立体效果是相同的，只是相对原点的位置变动了而已。在相机点(-160, -80)看到的立体效果，就等效于在相机点(0,0)看到的把layer平移(160, 80)的立体效果.对一个layer来说，只要没有修改anchorPoint，系统所认为的内部相机点的投影是在anchorPoint这个位置，也就是相机点的(0,0)位置。因此要看到layer在相机点(-160, -80)透视投影的效果，只能先作平移变换，让相机点与layer做相同的平移使相机点移到(0,0), 完成透视投影后再平移回去。</p>

<p>带透视效果的绕Y轴旋转，效果如下：<br/>
<img src="/images/CALayerTransform/CALayerProject.png" alt="test" /></p>

<p>相应的代码为：
<code>objc
CATransform3D rotate = CATransform3DMakeRotation(M_PI/6, 0, 1, 0);
image.layer.transform = CATransform3DPerspect(rotate, CGPointMake(0, 0), 200);
</code></p>

<p>可以发现在进行逆时针旋转30度时，在中心点左侧的图离相机点比较近，呈现出了比原图大的效果，右侧的图离相机点比较远，呈现出了比原图小的效果。对比原图，图的左边界超出了屏幕，而右边界在屏幕之内，这可以通过下面的这个图来解释：<br/>
<img src="/images/CALayerTransform/CALayerProject2.png" alt="test" /></p>

<p>图中PQ为旋转后的图像在X-Z平面上的投影，相机点在O点，从O点看过过，P、Q两点在X轴上的投影为C、D点，C、D两点相对P、Q点在X轴上的原始位置都是靠左的，这也就解释了旋转后的透视投影效果左边界超出了屏幕，右边界在屏幕之内。</p>

<p>上图中A、B两点是O点在无穷远处所看到的P、Q两点在X轴上的投影，也就是我们在第二张图片上看到的效果。这是因为在无穷远处，观察P、Q时已经失去了近大远小的效果，所做的投影是正交投影。</p>

<p>如果把center设为(-160,-80),也就是把相机位置设为矩形图片的左上角，则绕Y轴旋转的透视效果如下：<br/>
<img src="/images/CALayerTransform/CALayerProject3.png" alt="test" /></p>

<h3>立方体效果</h3>

<p>CATransform3D可以使用CATransform3DConcat函数连接起来以构造更复杂的变换, 通过这些方法，可以组合出更多的效果来。下面是个翻转的动画, 使用四张同样大小的图片围成一个框，让这个框动画旋转, 形成一个立方体旋转的效果。<br/>
<img src="/images/CALayerTransform/CALayerCube.png" alt="test" /></p>

<p>相关实现的代码：<br/>
```objc
CATransform3D move = CATransform3DMakeTranslation(0, 0, 160);
CATransform3D back = CATransform3DMakeTranslation(0, 0, -160);</p>

<p>CATransform3D rotate0 = CATransform3DMakeRotation(-angle, 0, 1, 0);
CATransform3D rotate1 = CATransform3DMakeRotation(M_PI_2-angle, 0, 1, 0);
CATransform3D rotate2 = CATransform3DMakeRotation(M_PI_2<em>2-angle, 0, 1, 0);
CATransform3D rotate3 = CATransform3DMakeRotation(M_PI_2</em>3-angle, 0, 1, 0);</p>

<p>CATransform3D mat0 = CATransform3DConcat(CATransform3DConcat(move, rotate0), back);
CATransform3D mat1 = CATransform3DConcat(CATransform3DConcat(move, rotate1), back);
CATransform3D mat2 = CATransform3DConcat(CATransform3DConcat(move, rotate2), back);
CATransform3D mat3 = CATransform3DConcat(CATransform3DConcat(move, rotate3), back);</p>

<p>image0.layer.transform = CATransform3DPerspect(mat0, CGPointZero, 500);
image1.layer.transform = CATransform3DPerspect(mat1, CGPointZero, 500);
image2.layer.transform = CATransform3DPerspect(mat2, CGPointZero, 500);
image3.layer.transform = CATransform3DPerspect(mat3, CGPointZero, 500);
```</p>

<p>解析：<br/>
要形成一个立方体旋转的效果，首先需要构造出一个立方体出来，怎么构造呢？在这个例子里构造的立方体是前后左右四个面的，如果把屏幕当做立方体的“前”面，它的“左”、“后”、“右”面我们是看不见，但是这三个面可以通过“前”面旋转一个角度得到的：以立方体的中心点为支点，将“前”面分别顺时针旋转90度、180度、270。因为屏幕宽度为320，这个立方体的中心点应在屏幕中心点后方160px的地方。</p>

<p>现在需要解决的一个问题就是：怎么实现以立方体的中心点为支点的旋转。我们知道，在CALayer中layer的旋转是以anchorPoint为支点的，而这个anchorPoint并没有在z轴上的维度，所以修改anchorPoint是不可能的，怎么办呢？答案还是通过平移实现，虽然不能修改anchorPoint，但我们可以改变图片的位置，将图片往z轴正方向(靠近用户的方向)平移160px的距离，这时候图片与anchorPoint的相对位置，就等同于图片在原始位置与立方体中心的相对位置，它们所进行的旋转效果是相同的，只是在z轴上的绝对距离不同。旋转完成后，再平移回去，即可达到绕立方体的中心点旋转的效果。这也是变换矩阵mat0为什么要先进行z轴正方向160px平移，执行rotate0旋转之后又进行z轴负方向160px平移的缘故。</p>

<p>要实现旋转动画，就需要动态改变这个立方体的绕y轴的角度，在这个例子里就是添加了一个动态变化的angle达到这个目的。另外注意此例的旋转是绕y轴旋转的，根据此前一篇文章的判断方法，此时旋转的正方向应该是z轴正方向顶点指向x轴正方向顶点，从用户眼睛看来就是逆时针。如果angle是递增的，那么-angle就是递减的，因此实际看到的旋转动画会是顺时针的。</p>

<p>在分析这个例子时，自己又突然想到另外一个问题：对一个layer做平移，会修改它的anchorPoint和position吗？很显然，对旋转和绽放必须要有一个固定的支点，感觉上平移不需要支点也行，是不是就会修改anchorPoint呢？答案是否定时，简单做一下测试，就知道layer在做平移时，anchorPoint和position都不会改变，frame会变化，说明frame不仅受anchorPoint和position影响，还受translation影响.</p>

<h4>参考链接</h4>

<ul>
<li><a href="http://www.cocoachina.com/bbs/read.php?tid=117061&amp;page=1">IOS 3D UI &mdash;&ndash; CALayer的transform扩展</a></li>
<li><a href="http://geeklu.com/2012/07/ios-3d-perspective/">iOS的三维透视投影</a></li>
<li><a href="http://www.cnblogs.com/healerkx/archive/2012/01/09/2317579.html">学习笔记5（CATransform3D-Cube）</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[判断三维坐标系旋转正方向的简单方法]]></title>
    <link href="http://wonderffee.github.io/blog/2013/10/17/a-simple-method-to-determine-positive-rotation-in-in-three-dimensional-space/"/>
    <updated>2013-10-17T22:26:00+08:00</updated>
    <id>http://wonderffee.github.io/blog/2013/10/17/a-simple-method-to-determine-positive-rotation-in-in-three-dimensional-space</id>
    <content type="html"><![CDATA[<h3>引言</h3>

<p>做iOS开发，不免要接触到一些特效，其中不乏3D特效，这时候就要对iOS所使用的坐标系了解才行。若不限于iOS开发，还有MacOS开发，若不知道它们所使用坐标系的不同，初学者会很容易陷于混乱，</p>

<!--more-->


<h3>三维坐标系</h3>

<p>做3D特效，就要用到三维坐标系，这是后人在笛卡尔的平面坐标系的基础上发明的。三维坐标系分两种，左手坐标系和右手坐标系，为什么用左手和右手来区分呢？这是因为当确定了x轴，y轴方向之后,z轴的方向的两种，它可以通过左手或右手来确定。下面就是这两个坐标系的规则示意图（图中固定了x轴的正方向向右，y轴的正方向向上）：</p>

<p><img src="/images/3d-coordinate-system/coordinate-system1.jpg" alt="左手坐标系与右手坐标系" /></p>

<p>相信大多数人对图中的右手坐标系很眼熟，没错，这就是初高中数学教材用到的三维坐标系，只是我们不一定知道它叫右手坐标系。</p>

<p>左手坐标系我们之前很少接触，但是在计算机图形学中这种坐标系非常重要，比如iOS的UIView使用的坐标系就是左手坐标系。有人可能会说，不对吧，UIView的坐标系是原点在左上角，y轴正方向向下，图中的不是这样啊，其实没错啦，把图中的左手坐标系沿x轴旋转180度就是原点在左上角的左手坐标系，区别就是旋转的角度不同而已。这是因为左手坐标系或者右手坐标系整体旋转后性质是不变的。</p>

<p>对坐标系使用左手与右手的命名，有一个作用就是用来方便判断旋转的正方向，这就是左手法则和右手法则。例如对左手坐标系，确定一个旋转轴后，左手握住拳头，拇指指向旋转轴的正方向，四指弯曲的方向为旋转的正方向。相应地，右手坐标系就用右手来判定。确定了旋转的正方向后，在公式计算中就很容易知道是该使用正角度还是负角度了。下图就是右手的例子：</p>

<p><img src="/images/3d-coordinate-system/coordinate-system2.jpg" alt="右手法则" /></p>

<p>但是，这个判断旋转正方向的方法还是不够快。给定任意一个旋转角度的三维坐标系，如果按上面的方法判断旋转正方向，首先，你得确定这个坐标系是左手坐标系还是右手坐标系，这时你会先拿出一只手来，像上图一样摆好三根手指的姿势来比对给定坐标系的x、y、z轴正方向看是否一致。然后根据旋转轴的正方向，用相应的手来判断旋转正方向。</p>

<p>其实，完全没有必要这么麻烦。怎么更方便地判断，且看我慢慢道来。</p>

<p>先看第一个图的两个坐标系，左边的为左手坐标系，右边的为右手坐标系，两坐标系的x轴和y轴正方向保持一致，z轴正方向相反。分别用左手法则与右手法则去判断它们各自绕z轴旋转的正方向，那么从我们眼睛看屏幕的角度来看，它们绕z轴旋转的正方向都是逆时针，这当然不会是巧合。观察这两个坐标系，就会发现这个逆时针方向与x轴正方向箭头顶点指向y轴正方向箭头顶点的方向一致，这说明绕z轴旋转的正方向与x轴正方向箭头顶端指向y轴正方向箭头顶端的方向有关联吗？我想是的。</p>

<p>然后再尝试判断两坐标系绕x轴旋转的正方向，它与y轴正方向顶端指向z轴正方向顶端的方向一致；而绕y轴旋转的正方向，与z轴正方向顶端指向x轴正方向顶端的方向一致。</p>

<h3>结论一</h3>

<p>据此，我觉得可以得出一个结论：对于任意旋转角度的三维坐标系，绕某一坐标轴旋转的正方向，与另外两个坐标轴的正方向顶端按X&mdash;>Y&mdash;>Z&mdash;>X的顺序进行指向的方向一致。</p>

<p>这就意味着，判断三维坐标系绕某一坐标轴旋转的正方向，不用事先知晓这个坐标系是左手坐标系还是右手坐标系，完全不需要你用手去比划.</p>

<p>反过来，既然判断旋转正方向这么容易，我们也可以利用它来快速判断一个坐标系是左手坐标系和右手坐标系：使用上述结论确定坐标系绕某一某旋转的正方向，然后逆用左手法则与右手法则，大拇指指向该轴的正方向，如果左手四指弯曲的方向与旋转的正方向一致，该坐标系就是左手坐标系，反之就是右手坐标系。</p>

<p>不过这还是复杂，还是需要用手比划。我突然想到了一个更好的方法：<br/>
想象y轴是一面墙，你面朝前方斜靠在墙上，可以假设你的头部为y轴正方向顶点，脚为x轴正方向顶点，那么z轴在你的左侧时就是左手坐标系，在右侧时就是右手坐标系。这个时候，人体的生长方向也刚好是绕z轴旋转的正方向。</p>

<h3>结论二</h3>

<p>再扩展一下就是：对于任意旋转角度的三维坐标系，想象你的脚踩在一个坐标轴（如x轴）正方向的顶点，头倚靠在其邻高坐标轴（如y轴）的正方向顶点，面朝背离原点的方向，那么，第三轴正方向顶点在你的左手边时，这个坐标系就是左手坐标系，在右手边时就是右手坐标系，而人体此时的生长方向就是绕第三轴(如z轴)旋转的正方向。<br/>
（注：这里的邻高坐标轴是我自己定义的一个概念，X轴的邻高坐标轴为Y轴，Y轴的邻高坐标轴为Z轴，Z轴的邻高坐标轴为X轴.）</p>

<p>在这个方法里，坐标系属性与绕坐标轴旋转正方向的判断达到了统一，从此可以抛弃左手法则与右手法则，也可以抛弃手指比划的方式来判断左右手坐标系，是不是会觉得很简单？</p>

<h4>参考链接：</h4>

<p><a href="http://geeklu.com/2012/06/3d-coordinate-system/">Mac，iOS界面中的三维坐标系</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[通过实例来理解position与anchorPoint]]></title>
    <link href="http://wonderffee.github.io/blog/2013/10/14/understand-anchorpoint-and-position-with-instance/"/>
    <updated>2013-10-14T22:58:00+08:00</updated>
    <id>http://wonderffee.github.io/blog/2013/10/14/understand-anchorpoint-and-position-with-instance</id>
    <content type="html"><![CDATA[<p><a href="http://wonderffee.github.io/blog/2013/10/13/understand-anchorpoint-and-position/">上一篇文章</a>写了一些对position与anchorPoint的理解，这次就拿一些实例来加深印象。文中的例子来自别人的一篇<a href="http://www.cnblogs.com/yyh123/p/3345097.html">博文</a>，例子是不错的，但是自己刚开始也没完全搞明白，现在完全弄懂了，在这里借用一下并加以扩展，希望对看到的人有所帮助。</p>

<!--more-->


<p>先把之前的结论贴出来：<br/>
1、position是layer中的anchorPoint在superLayer中的位置坐标。<br/>
2、互不影响原则：单独修改position与anchorPoint中任何一个属性都不影响另一个属性。<br/>
3、frame、position与anchorPoint有以下关系：<br/>
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">frame</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">position</span><span class="p">.</span><span class="n">x</span> <span class="o">&amp;</span><span class="n">ndash</span><span class="p">;</span> <span class="n">anchorPoint</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">;</span>
</span><span class='line'><span class="n">frame</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">position</span><span class="p">.</span><span class="n">y</span> <span class="o">&amp;</span><span class="n">ndash</span><span class="p">;</span> <span class="n">anchorPoint</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h3>1.创建一个CALayer，添加到控制器的view的layer中</h3>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">CALayer</span> <span class="o">*</span><span class="n">myLayer</span> <span class="o">=</span> <span class="p">[</span><span class="n">CALayer</span> <span class="n">layer</span><span class="p">];</span>
</span><span class='line'><span class="c1">// 设置层的宽度和高度（100x100）</span>
</span><span class='line'><span class="n">myLayer</span><span class="p">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
</span><span class='line'><span class="c1">// 设置层的位置</span>
</span><span class='line'><span class="n">myLayer</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
</span><span class='line'><span class="c1">// 设置层的背景颜色：红色</span>
</span><span class='line'><span class="n">myLayer</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIColor</span> <span class="n">redColor</span><span class="p">].</span><span class="n">CGColor</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">// 添加myLayer到控制器的view的layer中</span>
</span><span class='line'><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">layer</span> <span class="nl">addSublayer:</span><span class="n">myLayer</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>第5行设置了myLayer的position为(100, 100)，又因为anchorPoint默认是(0.5, 0.5)，所以最后的效果是：myLayer的中点会在父层的(100, 100)位置。</p>

<p>My Note:根据anchorPoint默认为(0.5, 0.5)以及结论3中的的公式，可以得到frame.origin为(50, 50),所以myLayer在图中左上角的位置应为(50, 50)。见下图:</p>

<p><img src="/images/anchorPointInstance/1.png"></p>

<h3>2.若将anchorPoint改为(0, 0)</h3>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">myLayer</span><span class="p">.</span><span class="n">anchorPoint</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>MyNote:根据结论2，修改anchorPoint不影响position，则frame.origin需要重新计算，如下：
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">frame</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">&amp;</span><span class="n">ndash</span><span class="p">;</span> <span class="mi">0</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
</span><span class='line'><span class="n">frame</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">&amp;</span><span class="n">ndash</span><span class="p">;</span> <span class="mi">0</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
这样，myLayer的左上角就会就会移动到(100, 100)的位置。见下图：<br/>
<img src="/images/anchorPointInstance/2.png"></p>

<h3>3.若将anchorPoint改为(1, 1)</h3>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">myLayer</span><span class="p">.</span><span class="n">anchorPoint</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>MyNote:同上，直接重新计算frame.origin，会得到frame.origin为(0, 0)，myLayer左上角移动到(0, 0)的位置，见图：<br/>
<img src="/images/anchorPointInstance/3.png"></p>

<h3>4.将anchorPoint改为(0, 1)</h3>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">myLayer</span><span class="p">.</span><span class="n">anchorPoint</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
MyNote:类似地，直接重新计算frame.origin，会得到frame.origin为(100, 0)，myLayer左上角移动到(100, 0)的位置，见图：  <br/>
<img src="/images/anchorPointInstance/4.png"></p>

<h3>5.设置frame与bounds的区别</h3>

<p>先看代码1：
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">CALayer</span> <span class="o">*</span><span class="n">myLayer1</span> <span class="o">=</span> <span class="p">[</span><span class="n">CALayer</span> <span class="n">layer</span><span class="p">];</span>
</span><span class='line'><span class="n">myLayer1</span><span class="p">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
</span><span class='line'><span class="n">myLayer1</span><span class="p">.</span><span class="n">anchorPoint</span> <span class="o">=</span> <span class="n">CGPointZero</span><span class="p">;</span>
</span><span class='line'><span class="n">myLayer1</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIColor</span> <span class="n">redColor</span><span class="p">].</span><span class="n">CGColor</span><span class="p">;</span>
</span><span class='line'><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">layer</span> <span class="nl">addSublayer:</span><span class="n">myLayer1</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>再看代码2：
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">CALayer</span> <span class="o">*</span><span class="n">myLayer2</span> <span class="o">=</span> <span class="p">[</span><span class="n">CALayer</span> <span class="n">layer</span><span class="p">];</span>
</span><span class='line'><span class="n">myLayer2</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
</span><span class='line'><span class="n">myLayer2</span><span class="p">.</span><span class="n">anchorPoint</span> <span class="o">=</span> <span class="n">CGPointZero</span><span class="p">;</span>
</span><span class='line'><span class="n">myLayer2</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIColor</span> <span class="n">redColor</span><span class="p">].</span><span class="n">CGColor</span><span class="p">;</span>
</span><span class='line'><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">layer</span> <span class="nl">addSublayer:</span><span class="n">myLayer2</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>区别在于第二行代码一个使用bounds,一个使用frame, 猜猜myLayer1和myLayer2左上角的位置会相同吗？</p>

<p>你可能觉得是相同的，但其实不同，myLayer1左上角在(0, 0)点，myLayer1却不是预期的(0, 0)点，而是在(50, 50)点，也就是例1中的图，为什么？有人可能还会说我明明想将myLayer2左上角放在原点，怎么就不是呢？</p>

<p>关键在于用的是frame。对于一个还没有superLayer的layer来说，position和anchorPoint都是有默认值的，分别为(0, 0)和(0.5, 0.5),如果对该layer设置了frame，因为anchorPoint还是保持默认值不会变化，只能是position随之变动。所以根据3中的公式，position的计算如下：
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">position</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">=</span> <span class="mi">50</span>
</span><span class='line'><span class="n">position</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">=</span> <span class="mi">50</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>position被确定为(50, 50)，接着在代码2中又修改anchorPoint为(0, 0), 这个时候不影响position的值，只能是frame.origin被修改，也就是变成下面的：
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">frame</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">50</span> <span class="o">&amp;</span><span class="n">ndash</span><span class="p">;</span> <span class="mi">0</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>
</span><span class='line'><span class="n">frame</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">50</span> <span class="o">&amp;</span><span class="n">ndash</span><span class="p">;</span> <span class="mi">0</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>所以对一个已经确定frame的layer来说，再修改anchorPoint就会修改layer的位置，如果只想修改anchorPoint而不改变layer的位置，就用代码1的方式来进行，或者把代码2中设置frame与anchorPoint的代码顺序调换一下，就能解决问题。</p>

<p>要记住的就是设置frame会隐式修改position，而默认的anchorPoint从来不会被隐式修改，只能被显式修改。</p>

<h4>参考</h4>

<ul>
<li><a href="http://www.cnblogs.com/yyh123/p/3345097.html">position和anchorPoint</a></li>
<li><a href="http://stackoverflow.com/questions/1968017/changing-my-calayers-anchorpoint-moves-the-view">Changing my CALayer&rsquo;s anchorPoint moves the view</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
