<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | Wonderffee's Blog]]></title>
  <link href="http://wonderffee.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://wonderffee.github.io/"/>
  <updated>2014-04-07T09:59:53+08:00</updated>
  <id>http://wonderffee.github.io/</id>
  <author>
    <name><![CDATA[wonderffee]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS 3D UI——CALayer的transform扩展解析]]></title>
    <link href="http://wonderffee.github.io/blog/2013/10/19/an-analysis-for-transform-samples-of-calayer/"/>
    <updated>2013-10-19T17:44:00+08:00</updated>
    <id>http://wonderffee.github.io/blog/2013/10/19/an-analysis-for-transform-samples-of-calayer</id>
    <content type="html"><![CDATA[<h3>引言</h3>

<p>这篇文章的主要内容来自于CocoaChina论坛上的一篇文章，只不过原文在有些地方介绍得不是很详细，我这里增加了一些解析，也算是自己做笔记，原文和代码均可以在这个链接里找到：<a href="http://www.cocoachina.com/bbs/read.php?tid=117061&amp;page=1">IOS 3D UI &mdash;&ndash; CALayer的transform扩展</a>。</p>

<!--more-->


<p>iOS的UI是基于UIView类的，我们能看到的每个UI元素都是UIView或者UIView的子类。View按树形结构组织起来，树根是UIWindow。</p>

<h3>UIView与CALayer</h3>

<p>View负责界面的交互和显示，其中显示部分由CALayer来完成。每个UIView包含一个CALayer实例。可以这么认为，UIView本身是不可见的，我们能看到的都是CALayer，UIView只是负责对CALayer进行管理。</p>

<p>UIView的显示设置都是对CALayer属性的封装，但是这层封装掩盖了CALayer提供的3D显示功能。所以我们想让UIView显示3D的效果的话，需要直接操作CALayer。</p>

<p>要操作CALayer对象，首先要在工程中包含QuartzCore.framework，在文件中import &lt;QuartzCore/QuartzCore.h>头文件。QuartzCore.framework中包含了CALayer以及CALayer一些官方子类的定义。</p>

<p>通过设置CALayer的transform属性，可以使CALayer产生3D空间内的平移、缩放、旋转等变化。</p>

<h3>绕坐标轴的旋转</h3>

<p>原始场景如图：</p>

<p><img src="/images/CALayerTransform/CALayerOrigin.png" alt="test" /></p>

<p>使用image.layer.transform = CATransform3DMakeRotation(M_PI/6, 0, 1, 0); 绕Y轴旋转30度后的效果:</p>

<p><img src="/images/CALayerTransform/CALayerRotation30y.png" alt="test" /></p>

<p>可以发现，绕Y轴旋转只是在X轴上进行了缩放，这是因为，在CALayer的显示系统中，默认的相机使用正交投影，正交投影没有远小近大效果，所以在本例中，只能造成相应轴上的缩放。在这种情况下，无论是绕Y轴旋转30度还是-30度都是同样的效果。</p>

<h3>透视投影</h3>

<p>CALayer默认使用正交投影，因此没有远小近大效果，而且没有明确的API可以使用透视投影矩阵。所幸可以通过矩阵连乘自己构造透视投影矩阵。构造透视投影矩阵的代码如下：
```objc</p>

<pre><code>CATransform3D CATransform3DMakePerspective(CGPoint center, float disZ)
{
    CATransform3D transToCenter = CATransform3DMakeTranslation(-center.x, -center.y, 0);
    CATransform3D transBack = CATransform3DMakeTranslation(center.x, center.y, 0);
    CATransform3D scale = CATransform3DIdentity;
    scale.m34 = -1.0f/disZ;
    return CATransform3DConcat(CATransform3DConcat(transToCenter, scale), transBack);
}

CATransform3D CATransform3DPerspect(CATransform3D t, CGPoint center, float disZ)
{ 
    return CATransform3DConcat(t, CATransform3DMakePerspective(center, disZ));
}
</code></pre>

<p>```</p>

<p>代码中，center指的是相机 的位置，相机的位置是相对于要进行变换的CALayer的来说的，原点是CALayer的anchorPoint在整个CALayer的位置，例如CALayer的大小是(320, 160), anchorPoint值为(0.5, 0.5)，此时anchorPoint在整个CALayer中的位置就是(160, 80)，正中心的位置。传入透视变换的相机位置为(0, 0)，那么相机所在的位置相对于CALayer就是(160, 80)。如果希望相机在左上角，则需要传入(-160, -80)。disZ表示的是相机离z=0平面（也可以理解为屏幕）的距离。</p>

<p>怎么解释这段代码呢？
第一步，layer在CATransform3DPerspect方法中首先进行了t变换，要注意的是这时候进行的t变换是以anchorPoint为中心点，默认情况下是在layer的中心位置。</p>

<p>第二步，在CATransform3DMakePerspective方法先进行了一个(-center.x, -center.y, 0)的平移，然后进行了透视投影，最后又做了一个(center.x, center.y, 0)平移。关键在于这两个反向的平移。
当center为(0,0)也就是相机中心在CALayer的中心位置，与anchorPoint(0.5, 0.5)重合时，平移的距离为0也就是没有做平移，这时候是直接把已经做过t变换的layer通过scale进行透视投影变换的。</p>

<p>当center不在中心位置时，假设在CALayer的左上角，那么center为(-160, -80)。那center就平移到了(0,0)点，等于把相机点又平移回到了与anchorPoint重合的这一点，但由于平移此时这个重合点成矩形图片的左上角了。那么为什么要平移至使相机点与anchorPoint点重合呢？</p>

<p>这里得明确一点，相机点与layer同时在X-Y平面上做相同的偏移时，因为没有改变z值，在相机点看到的立体效果是相同的，只是相对原点的位置变动了而已。在相机点(-160, -80)看到的立体效果，就等效于在相机点(0,0)看到的把layer平移(160, 80)的立体效果.对一个layer来说，只要没有修改anchorPoint，系统所认为的内部相机点的投影是在anchorPoint这个位置，也就是相机点的(0,0)位置。因此要看到layer在相机点(-160, -80)透视投影的效果，只能先作平移变换，让相机点与layer做相同的平移使相机点移到(0,0), 完成透视投影后再平移回去。</p>

<p>带透视效果的绕Y轴旋转，效果如下：<br/>
<img src="/images/CALayerTransform/CALayerProject.png" alt="test" /></p>

<p>相应的代码为：
<code>objc
CATransform3D rotate = CATransform3DMakeRotation(M_PI/6, 0, 1, 0);
image.layer.transform = CATransform3DPerspect(rotate, CGPointMake(0, 0), 200);
</code></p>

<p>可以发现在进行逆时针旋转30度时，在中心点左侧的图离相机点比较近，呈现出了比原图大的效果，右侧的图离相机点比较远，呈现出了比原图小的效果。对比原图，图的左边界超出了屏幕，而右边界在屏幕之内，这可以通过下面的这个图来解释：<br/>
<img src="/images/CALayerTransform/CALayerProject2.png" alt="test" /></p>

<p>图中PQ为旋转后的图像在X-Z平面上的投影，相机点在O点，从O点看过过，P、Q两点在X轴上的投影为C、D点，C、D两点相对P、Q点在X轴上的原始位置都是靠左的，这也就解释了旋转后的透视投影效果左边界超出了屏幕，右边界在屏幕之内。</p>

<p>上图中A、B两点是O点在无穷远处所看到的P、Q两点在X轴上的投影，也就是我们在第二张图片上看到的效果。这是因为在无穷远处，观察P、Q时已经失去了近大远小的效果，所做的投影是正交投影。</p>

<p>如果把center设为(-160,-80),也就是把相机位置设为矩形图片的左上角，则绕Y轴旋转的透视效果如下：<br/>
<img src="/images/CALayerTransform/CALayerProject3.png" alt="test" /></p>

<h3>立方体效果</h3>

<p>CATransform3D可以使用CATransform3DConcat函数连接起来以构造更复杂的变换, 通过这些方法，可以组合出更多的效果来。下面是个翻转的动画, 使用四张同样大小的图片围成一个框，让这个框动画旋转, 形成一个立方体旋转的效果。<br/>
<img src="/images/CALayerTransform/CALayerCube.png" alt="test" /></p>

<p>相关实现的代码：<br/>
```objc
CATransform3D move = CATransform3DMakeTranslation(0, 0, 160);
CATransform3D back = CATransform3DMakeTranslation(0, 0, -160);</p>

<p>CATransform3D rotate0 = CATransform3DMakeRotation(-angle, 0, 1, 0);
CATransform3D rotate1 = CATransform3DMakeRotation(M_PI_2-angle, 0, 1, 0);
CATransform3D rotate2 = CATransform3DMakeRotation(M_PI_2<em>2-angle, 0, 1, 0);
CATransform3D rotate3 = CATransform3DMakeRotation(M_PI_2</em>3-angle, 0, 1, 0);</p>

<p>CATransform3D mat0 = CATransform3DConcat(CATransform3DConcat(move, rotate0), back);
CATransform3D mat1 = CATransform3DConcat(CATransform3DConcat(move, rotate1), back);
CATransform3D mat2 = CATransform3DConcat(CATransform3DConcat(move, rotate2), back);
CATransform3D mat3 = CATransform3DConcat(CATransform3DConcat(move, rotate3), back);</p>

<p>image0.layer.transform = CATransform3DPerspect(mat0, CGPointZero, 500);
image1.layer.transform = CATransform3DPerspect(mat1, CGPointZero, 500);
image2.layer.transform = CATransform3DPerspect(mat2, CGPointZero, 500);
image3.layer.transform = CATransform3DPerspect(mat3, CGPointZero, 500);
```</p>

<p>解析：<br/>
要形成一个立方体旋转的效果，首先需要构造出一个立方体出来，怎么构造呢？在这个例子里构造的立方体是前后左右四个面的，如果把屏幕当做立方体的“前”面，它的“左”、“后”、“右”面我们是看不见，但是这三个面可以通过“前”面旋转一个角度得到的：以立方体的中心点为支点，将“前”面分别顺时针旋转90度、180度、270。因为屏幕宽度为320，这个立方体的中心点应在屏幕中心点后方160px的地方。</p>

<p>现在需要解决的一个问题就是：怎么实现以立方体的中心点为支点的旋转。我们知道，在CALayer中layer的旋转是以anchorPoint为支点的，而这个anchorPoint并没有在z轴上的维度，所以修改anchorPoint是不可能的，怎么办呢？答案还是通过平移实现，虽然不能修改anchorPoint，但我们可以改变图片的位置，将图片往z轴正方向(靠近用户的方向)平移160px的距离，这时候图片与anchorPoint的相对位置，就等同于图片在原始位置与立方体中心的相对位置，它们所进行的旋转效果是相同的，只是在z轴上的绝对距离不同。旋转完成后，再平移回去，即可达到绕立方体的中心点旋转的效果。这也是变换矩阵mat0为什么要先进行z轴正方向160px平移，执行rotate0旋转之后又进行z轴负方向160px平移的缘故。</p>

<p>要实现旋转动画，就需要动态改变这个立方体的绕y轴的角度，在这个例子里就是添加了一个动态变化的angle达到这个目的。另外注意此例的旋转是绕y轴旋转的，根据此前一篇文章的判断方法，此时旋转的正方向应该是z轴正方向顶点指向x轴正方向顶点，从用户眼睛看来就是逆时针。如果angle是递增的，那么-angle就是递减的，因此实际看到的旋转动画会是顺时针的。</p>

<p>在分析这个例子时，自己又突然想到另外一个问题：对一个layer做平移，会修改它的anchorPoint和position吗？很显然，对旋转和绽放必须要有一个固定的支点，感觉上平移不需要支点也行，是不是就会修改anchorPoint呢？答案是否定时，简单做一下测试，就知道layer在做平移时，anchorPoint和position都不会改变，frame会变化，说明frame不仅受anchorPoint和position影响，还受translation影响.</p>

<h4>参考链接</h4>

<ul>
<li><a href="http://www.cocoachina.com/bbs/read.php?tid=117061&amp;page=1">IOS 3D UI &mdash;&ndash; CALayer的transform扩展</a></li>
<li><a href="http://geeklu.com/2012/07/ios-3d-perspective/">iOS的三维透视投影</a></li>
<li><a href="http://www.cnblogs.com/healerkx/archive/2012/01/09/2317579.html">学习笔记5（CATransform3D-Cube）</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[判断三维坐标系旋转正方向的简单方法]]></title>
    <link href="http://wonderffee.github.io/blog/2013/10/17/a-simple-method-to-determine-positive-rotation-in-in-three-dimensional-space/"/>
    <updated>2013-10-17T22:26:00+08:00</updated>
    <id>http://wonderffee.github.io/blog/2013/10/17/a-simple-method-to-determine-positive-rotation-in-in-three-dimensional-space</id>
    <content type="html"><![CDATA[<h3>引言</h3>

<p>做iOS开发，不免要接触到一些特效，其中不乏3D特效，这时候就要对iOS所使用的坐标系了解才行。若不限于iOS开发，还有MacOS开发，若不知道它们所使用坐标系的不同，初学者会很容易陷于混乱，</p>

<!--more-->


<h3>三维坐标系</h3>

<p>做3D特效，就要用到三维坐标系，这是后人在笛卡尔的平面坐标系的基础上发明的。三维坐标系分两种，左手坐标系和右手坐标系，为什么用左手和右手来区分呢？这是因为当确定了x轴，y轴方向之后,z轴的方向的两种，它可以通过左手或右手来确定。下面就是这两个坐标系的规则示意图（图中固定了x轴的正方向向右，y轴的正方向向上）：</p>

<p><img src="/images/3d-coordinate-system/coordinate-system1.jpg" alt="左手坐标系与右手坐标系" /></p>

<p>相信大多数人对图中的右手坐标系很眼熟，没错，这就是初高中数学教材用到的三维坐标系，只是我们不一定知道它叫右手坐标系。</p>

<p>左手坐标系我们之前很少接触，但是在计算机图形学中这种坐标系非常重要，比如iOS的UIView使用的坐标系就是左手坐标系。有人可能会说，不对吧，UIView的坐标系是原点在左上角，y轴正方向向下，图中的不是这样啊，其实没错啦，把图中的左手坐标系沿x轴旋转180度就是原点在左上角的左手坐标系，区别就是旋转的角度不同而已。这是因为左手坐标系或者右手坐标系整体旋转后性质是不变的。</p>

<p>对坐标系使用左手与右手的命名，有一个作用就是用来方便判断旋转的正方向，这就是左手法则和右手法则。例如对左手坐标系，确定一个旋转轴后，左手握住拳头，拇指指向旋转轴的正方向，四指弯曲的方向为旋转的正方向。相应地，右手坐标系就用右手来判定。确定了旋转的正方向后，在公式计算中就很容易知道是该使用正角度还是负角度了。下图就是右手的例子：</p>

<p><img src="/images/3d-coordinate-system/coordinate-system2.jpg" alt="右手法则" /></p>

<p>但是，这个判断旋转正方向的方法还是不够快。给定任意一个旋转角度的三维坐标系，如果按上面的方法判断旋转正方向，首先，你得确定这个坐标系是左手坐标系还是右手坐标系，这时你会先拿出一只手来，像上图一样摆好三根手指的姿势来比对给定坐标系的x、y、z轴正方向看是否一致。然后根据旋转轴的正方向，用相应的手来判断旋转正方向。</p>

<p>其实，完全没有必要这么麻烦。怎么更方便地判断，且看我慢慢道来。</p>

<p>先看第一个图的两个坐标系，左边的为左手坐标系，右边的为右手坐标系，两坐标系的x轴和y轴正方向保持一致，z轴正方向相反。分别用左手法则与右手法则去判断它们各自绕z轴旋转的正方向，那么从我们眼睛看屏幕的角度来看，它们绕z轴旋转的正方向都是逆时针，这当然不会是巧合。观察这两个坐标系，就会发现这个逆时针方向与x轴正方向箭头顶点指向y轴正方向箭头顶点的方向一致，这说明绕z轴旋转的正方向与x轴正方向箭头顶端指向y轴正方向箭头顶端的方向有关联吗？我想是的。</p>

<p>然后再尝试判断两坐标系绕x轴旋转的正方向，它与y轴正方向顶端指向z轴正方向顶端的方向一致；而绕y轴旋转的正方向，与z轴正方向顶端指向x轴正方向顶端的方向一致。</p>

<h3>结论一</h3>

<p>据此，我觉得可以得出一个结论：对于任意旋转角度的三维坐标系，绕某一坐标轴旋转的正方向，与另外两个坐标轴的正方向顶端按X&mdash;>Y&mdash;>Z&mdash;>X的顺序进行指向的方向一致。</p>

<p>这就意味着，判断三维坐标系绕某一坐标轴旋转的正方向，不用事先知晓这个坐标系是左手坐标系还是右手坐标系，完全不需要你用手去比划.</p>

<p>反过来，既然判断旋转正方向这么容易，我们也可以利用它来快速判断一个坐标系是左手坐标系和右手坐标系：使用上述结论确定坐标系绕某一某旋转的正方向，然后逆用左手法则与右手法则，大拇指指向该轴的正方向，如果左手四指弯曲的方向与旋转的正方向一致，该坐标系就是左手坐标系，反之就是右手坐标系。</p>

<p>不过这还是复杂，还是需要用手比划。我突然想到了一个更好的方法：<br/>
想象y轴是一面墙，你面朝前方斜靠在墙上，可以假设你的头部为y轴正方向顶点，脚为x轴正方向顶点，那么z轴在你的左侧时就是左手坐标系，在右侧时就是右手坐标系。这个时候，人体的生长方向也刚好是绕z轴旋转的正方向。</p>

<h3>结论二</h3>

<p>再扩展一下就是：对于任意旋转角度的三维坐标系，想象你的脚踩在一个坐标轴（如x轴）正方向的顶点，头倚靠在其邻高坐标轴（如y轴）的正方向顶点，面朝背离原点的方向，那么，第三轴正方向顶点在你的左手边时，这个坐标系就是左手坐标系，在右手边时就是右手坐标系，而人体此时的生长方向就是绕第三轴(如z轴)旋转的正方向。<br/>
（注：这里的邻高坐标轴是我自己定义的一个概念，X轴的邻高坐标轴为Y轴，Y轴的邻高坐标轴为Z轴，Z轴的邻高坐标轴为X轴.）</p>

<p>在这个方法里，坐标系属性与绕坐标轴旋转正方向的判断达到了统一，从此可以抛弃左手法则与右手法则，也可以抛弃手指比划的方式来判断左右手坐标系，是不是会觉得很简单？</p>

<h4>参考链接：</h4>

<p><a href="http://geeklu.com/2012/06/3d-coordinate-system/">Mac，iOS界面中的三维坐标系</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[通过实例来理解position与anchorPoint]]></title>
    <link href="http://wonderffee.github.io/blog/2013/10/14/understand-anchorpoint-and-position-with-instance/"/>
    <updated>2013-10-14T22:58:00+08:00</updated>
    <id>http://wonderffee.github.io/blog/2013/10/14/understand-anchorpoint-and-position-with-instance</id>
    <content type="html"><![CDATA[<p><a href="http://wonderffee.github.io/blog/2013/10/13/understand-anchorpoint-and-position/">上一篇文章</a>写了一些对position与anchorPoint的理解，这次就拿一些实例来加深印象。文中的例子来自别人的一篇<a href="http://www.cnblogs.com/yyh123/p/3345097.html">博文</a>，例子是不错的，但是自己刚开始也没完全搞明白，现在完全弄懂了，在这里借用一下并加以扩展，希望对看到的人有所帮助。</p>

<!--more-->


<p>先把之前的结论贴出来：<br/>
1、position是layer中的anchorPoint在superLayer中的位置坐标。<br/>
2、互不影响原则：单独修改position与anchorPoint中任何一个属性都不影响另一个属性。<br/>
3、frame、position与anchorPoint有以下关系：<br/>
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">frame</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">position</span><span class="p">.</span><span class="n">x</span> <span class="o">&amp;</span><span class="n">ndash</span><span class="p">;</span> <span class="n">anchorPoint</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">;</span>
</span><span class='line'><span class="n">frame</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">position</span><span class="p">.</span><span class="n">y</span> <span class="o">&amp;</span><span class="n">ndash</span><span class="p">;</span> <span class="n">anchorPoint</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h3>1.创建一个CALayer，添加到控制器的view的layer中</h3>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">CALayer</span> <span class="o">*</span><span class="n">myLayer</span> <span class="o">=</span> <span class="p">[</span><span class="n">CALayer</span> <span class="n">layer</span><span class="p">];</span>
</span><span class='line'><span class="c1">// 设置层的宽度和高度（100x100）</span>
</span><span class='line'><span class="n">myLayer</span><span class="p">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
</span><span class='line'><span class="c1">// 设置层的位置</span>
</span><span class='line'><span class="n">myLayer</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
</span><span class='line'><span class="c1">// 设置层的背景颜色：红色</span>
</span><span class='line'><span class="n">myLayer</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIColor</span> <span class="n">redColor</span><span class="p">].</span><span class="n">CGColor</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">// 添加myLayer到控制器的view的layer中</span>
</span><span class='line'><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">layer</span> <span class="nl">addSublayer:</span><span class="n">myLayer</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>第5行设置了myLayer的position为(100, 100)，又因为anchorPoint默认是(0.5, 0.5)，所以最后的效果是：myLayer的中点会在父层的(100, 100)位置。</p>

<p>My Note:根据anchorPoint默认为(0.5, 0.5)以及结论3中的的公式，可以得到frame.origin为(50, 50),所以myLayer在图中左上角的位置应为(50, 50)。见下图:</p>

<p><img src="/images/anchorPointInstance/1.png"></p>

<h3>2.若将anchorPoint改为(0, 0)</h3>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">myLayer</span><span class="p">.</span><span class="n">anchorPoint</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>MyNote:根据结论2，修改anchorPoint不影响position，则frame.origin需要重新计算，如下：
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">frame</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">&amp;</span><span class="n">ndash</span><span class="p">;</span> <span class="mi">0</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
</span><span class='line'><span class="n">frame</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">&amp;</span><span class="n">ndash</span><span class="p">;</span> <span class="mi">0</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
这样，myLayer的左上角就会就会移动到(100, 100)的位置。见下图：<br/>
<img src="/images/anchorPointInstance/2.png"></p>

<h3>3.若将anchorPoint改为(1, 1)</h3>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">myLayer</span><span class="p">.</span><span class="n">anchorPoint</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>MyNote:同上，直接重新计算frame.origin，会得到frame.origin为(0, 0)，myLayer左上角移动到(0, 0)的位置，见图：<br/>
<img src="/images/anchorPointInstance/3.png"></p>

<h3>4.将anchorPoint改为(0, 1)</h3>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">myLayer</span><span class="p">.</span><span class="n">anchorPoint</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
MyNote:类似地，直接重新计算frame.origin，会得到frame.origin为(100, 0)，myLayer左上角移动到(100, 0)的位置，见图：  <br/>
<img src="/images/anchorPointInstance/4.png"></p>

<h3>5.设置frame与bounds的区别</h3>

<p>先看代码1：
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">CALayer</span> <span class="o">*</span><span class="n">myLayer1</span> <span class="o">=</span> <span class="p">[</span><span class="n">CALayer</span> <span class="n">layer</span><span class="p">];</span>
</span><span class='line'><span class="n">myLayer1</span><span class="p">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
</span><span class='line'><span class="n">myLayer1</span><span class="p">.</span><span class="n">anchorPoint</span> <span class="o">=</span> <span class="n">CGPointZero</span><span class="p">;</span>
</span><span class='line'><span class="n">myLayer1</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIColor</span> <span class="n">redColor</span><span class="p">].</span><span class="n">CGColor</span><span class="p">;</span>
</span><span class='line'><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">layer</span> <span class="nl">addSublayer:</span><span class="n">myLayer1</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>再看代码2：
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">CALayer</span> <span class="o">*</span><span class="n">myLayer2</span> <span class="o">=</span> <span class="p">[</span><span class="n">CALayer</span> <span class="n">layer</span><span class="p">];</span>
</span><span class='line'><span class="n">myLayer2</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
</span><span class='line'><span class="n">myLayer2</span><span class="p">.</span><span class="n">anchorPoint</span> <span class="o">=</span> <span class="n">CGPointZero</span><span class="p">;</span>
</span><span class='line'><span class="n">myLayer2</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIColor</span> <span class="n">redColor</span><span class="p">].</span><span class="n">CGColor</span><span class="p">;</span>
</span><span class='line'><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">layer</span> <span class="nl">addSublayer:</span><span class="n">myLayer2</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>区别在于第二行代码一个使用bounds,一个使用frame, 猜猜myLayer1和myLayer2左上角的位置会相同吗？</p>

<p>你可能觉得是相同的，但其实不同，myLayer1左上角在(0, 0)点，myLayer1却不是预期的(0, 0)点，而是在(50, 50)点，也就是例1中的图，为什么？有人可能还会说我明明想将myLayer2左上角放在原点，怎么就不是呢？</p>

<p>关键在于用的是frame。对于一个还没有superLayer的layer来说，position和anchorPoint都是有默认值的，分别为(0, 0)和(0.5, 0.5),如果对该layer设置了frame，因为anchorPoint还是保持默认值不会变化，只能是position随之变动。所以根据3中的公式，position的计算如下：
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">position</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">=</span> <span class="mi">50</span>
</span><span class='line'><span class="n">position</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">=</span> <span class="mi">50</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>position被确定为(50, 50)，接着在代码2中又修改anchorPoint为(0, 0), 这个时候不影响position的值，只能是frame.origin被修改，也就是变成下面的：
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">frame</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">50</span> <span class="o">&amp;</span><span class="n">ndash</span><span class="p">;</span> <span class="mi">0</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>
</span><span class='line'><span class="n">frame</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">50</span> <span class="o">&amp;</span><span class="n">ndash</span><span class="p">;</span> <span class="mi">0</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>所以对一个已经确定frame的layer来说，再修改anchorPoint就会修改layer的位置，如果只想修改anchorPoint而不改变layer的位置，就用代码1的方式来进行，或者把代码2中设置frame与anchorPoint的代码顺序调换一下，就能解决问题。</p>

<p>要记住的就是设置frame会隐式修改position，而默认的anchorPoint从来不会被隐式修改，只能被显式修改。</p>

<h4>参考</h4>

<ul>
<li><a href="http://www.cnblogs.com/yyh123/p/3345097.html">position和anchorPoint</a></li>
<li><a href="http://stackoverflow.com/questions/1968017/changing-my-calayers-anchorpoint-moves-the-view">Changing my CALayer&rsquo;s anchorPoint moves the view</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[彻底理解position与anchorPoint]]></title>
    <link href="http://wonderffee.github.io/blog/2013/10/13/understand-anchorpoint-and-position/"/>
    <updated>2013-10-13T11:10:00+08:00</updated>
    <id>http://wonderffee.github.io/blog/2013/10/13/understand-anchorpoint-and-position</id>
    <content type="html"><![CDATA[<h3>引言</h3>

<p>相信初接触到CALayer的人都会遇到以下几个问题： <br/>
为什么修改anchorPoint会移动layer的位置？<br/>
CALayer的position点是哪一点呢?<br/>
anchorPoint与position有什么关系？</p>

<!--more-->


<p>我也迷惑过，找过网上的教程，大部分都是复制粘贴的，有些是翻译的文章但很有问题，看得似懂非懂，还是自己写代码彻底弄懂了，做点笔记吧。</p>

<p>每一个UIView内部都默认关联着一个CALayer, UIView有frame、bounds和center三个属性，CALayer也有类似的属性，分别为frame、bounds、position、anchorPoint。frame和bounds比较好理解，bounds可以视为x坐标和y坐标都为0的frame，那position、anchorPoint是什么呢？先看看两者的原型，可知都是CGPoint点。</p>

<p>@property CGPoint position<br/>
@property CGPoint anchorPoint</p>

<h3>anchorPoint</h3>

<p>一般都是先介绍position，再介绍anchorPoint。我这里反过来，先来说说anchorPoint。</p>

<p>从一个例子开始入手吧，想象一下，把一张A4白纸用图钉订在书桌上，如果订得不是很紧的话，白纸就可以沿顺时针或逆时针方向围绕图钉旋转，这时候图钉就起着支点的作用。我们要解释的anchorPoint就相当于白纸上的图钉，它主要的作用就是用来作为变换的支点，旋转就是一种变换，类似的还有平移、缩放。</p>

<p>继续扩展，很明显，白纸的旋转形态随图钉的位置不同而不同，图钉订在白纸的正中间与左上角时分别造就了两种旋转形态，这是由图钉（anchorPoint）的位置决定的。如何衡量图钉（anchorPoint）在白纸中的位置呢？在iOS中，anchorPoint点的值是用一种相对bounds的比例值来确定的，在白纸的左上角、右下角，anchorPoint分为为(0,0), (1, 1)，也就是说anchorPoint是在单元坐标空间(同时也是左手坐标系)中定义的。类似地，可以得出在白纸的中心点、左下角和右上角的anchorPoint为(0.5,0.5), (0,1), (1,0)。</p>

<p>然后再来看下面两张图，注意图中分iOS与MacOS，因为两者的坐标系不相同，iOS使用左手坐标系，坐标原点在左上角，MacOS使用右手坐标系，原点在左下角，我们看iOS部分即可。
<img src="/images/anchorPointAndPosition/layer_coords_anchorpoint_position_2x.png" title="Optional title" alt="test" />  <br/>
图1</p>

<p><img src="/images/anchorPointAndPosition/anchorpoint2.jpg" title="Optional title" alt="test" />  <br/>
图2</p>

<p>像UIView有superView与subView的概念一样，CALayer也有superLayer与layer的概念，前面说到的白纸和图中的矩形可以理解为layer，书桌和图中矩形以外的坐标系可以理解成superLayer。如果各自以左上角为原点，则在图中有相对的两个坐标空间。</p>

<h3>position</h3>

<p>在图1中，anchorPoint有(0.5,0.5)和(0,0)两种情况，分别为矩形的中心点与原点。那么，这两个anchorPoint在superLayer中的实际位置分别为多少呢？简单计算一下就可以得到(100, 100)和(40, 60)，把这两个值分别与各自的position值比较，发现完全一致，该不会是巧合？</p>

<p>这时候可以大胆猜测一下，position是不是就是anchorPoint在superLayer中的位置呢？答案是确定的，更确切地说，position是layer中的anchorPoint点在superLayer中的位置坐标。因此可以说, position点是相对suerLayer的，anchorPoint点是相对layer的，两者是相对不同的坐标空间的一个重合点。</p>

<p>再来看看position的原始定义：
The layer’s position in its superlayer’s coordinate space。<br/>
中文可以理解成为position是layer相对superLayer坐标空间的位置，很显然，这里的位置是根据anchorPoint来确定的。</p>

<p>图2中是矩形沿不同的anchorPoint点旋转的形态，这就是类似于刚才讲的图钉订在白纸的正中间与左上角时分别造就了两种旋转形态。</p>

<h3>anchorPoint、position、frame</h3>

<p>anchorPoint的默认值为(0.5,0.5)，也就是anchorPoint默认在layer的中心点。默认情况下，使用addSublayer函数添加layer时，如果已知layer的frame值，根据上面的结论，那么position的值便可以用下面的公式计算：
<code>
position.x = frame.origin.x + 0.5 * bounds.size.width；  
position.y = frame.origin.y + 0.5 * bounds.size.height；  
</code></p>

<p>里面的0.5是因为anchorPoint取默认值，更通用的公式应该是下面的：<br/>
<code>
position.x = frame.origin.x + anchorPoint.x * bounds.size.width；  
position.y = frame.origin.y + anchorPoint.y * bounds.size.height；
</code></p>

<p>下面再来看另外两个问题，如果单方面修改layer的position位置，会对anchorPoint有什么影响呢？修改anchorPoint又如何影响position呢？  <br/>
根据代码测试，两者互不影响，受影响的只会是frame.origin，也就是layer坐标原点相对superLayer会有所改变。换句话说，frame.origin由position和anchorPoint共同决定，上面的公式可以变换成下面这样的：<br/>
<code>
frame.origin.x = position.x - anchorPoint.x * bounds.size.width；  
frame.origin.y = position.y - anchorPoint.y * bounds.size.height；
</code></p>

<p>这就解释了为什么修改anchorPoint会移动layer，因为position不受影响，只能是frame.origin做相应的改变，因而会移动layer。</p>

<h3>理解与运用</h3>

<p>在Apple doc对frame的描述中有这么一句话：</p>

<blockquote><p>Layers have an implicit frame that is a function of the position, bounds, anchorPoint, and transform properties.</p></blockquote>

<p>可以看到我们推导的公式基本符合这段描述，只不过还缺少了transform，加上transform的话就比较复杂，这里就不展开讲了。</p>

<hr />

<p>Apple doc中还有一句描述是这样的：</p>

<blockquote><p>When you specify the frame of a layer, position is set relative to the anchor point. When you specify the position of the layer, bounds is set relative to the anchor point.</p></blockquote>

<p>大意是：当你设置图层的frame属性的时候，position根据锚点（anchorPoint）的值来确定，而当你设置图层的position属性的时候，bounds会根据锚点(anchorPoint)来确定。</p>

<p>这段翻译的上半句根据前面的公式容易理解，后半句可能就有点令人迷惑了，当修改position时，bounds的width与height会随之修改吗？其实,position是点，bounds是矩形，根据锚点(anchorPoint)来确定的只是它们的位置，而不是内部属性。所以，上面这段英文这么翻译就容易理解了：</p>

<blockquote><p>当你设置图层的frame属性的时候，position点的位置（也就是position坐标）根据锚点（anchorPoint）的值来确定，而当你设置图层的position属性的时候，bounds的位置（也就是frame的orgin坐标）会根据锚点(anchorPoint)来确定。</p></blockquote>

<p>在实际情况中，可能还有这样一种需求，我需要修改anchorPoint，但又不想要移动layer也就是不想修改frame.origin，那么根据前面的公式，就需要position做相应地修改。简单地推导，可以得到下面的公式：
<code>  
positionNew.x = positionOld.x + (anchorPointNew.x - anchorPointOld.x)  * bounds.size.width  
positionNew.y = positionOld.y + (anchorPointNew.y - anchorPointOld.y)  * bounds.size.height
</code></p>

<p>但是在实际使用没必要这么麻烦。修改anchorPoint而不想移动layer，在修改anchorPoint后再重新设置一遍frame就可以达到目的，这时position就会自动进行相应的改变。写成函数就是下面这样的：
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="o">&amp;</span><span class="n">ndash</span><span class="p">;</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="nl">setAnchorPoint:</span><span class="p">(</span><span class="n">CGPoint</span><span class="p">)</span><span class="n">anchorpoint</span> <span class="nl">forView:</span><span class="p">(</span><span class="n">UIView</span> <span class="o">*</span><span class="p">)</span><span class="n">view</span><span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">CGRect</span> <span class="n">oldFrame</span> <span class="o">=</span> <span class="n">view</span><span class="p">.</span><span class="n">frame</span><span class="p">;</span>
</span><span class='line'><span class="n">view</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">anchorPoint</span> <span class="o">=</span> <span class="n">anchorpoint</span><span class="p">;</span>
</span><span class='line'><span class="n">view</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="n">oldFrame</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h3>总结</h3>

<p>1、position是layer中的anchorPoint在superLayer中的位置坐标。<br/>
2、互不影响原则：单独修改position与anchorPoint中任何一个属性都不影响另一个属性。<br/>
3、frame、position与anchorPoint有以下关系：<br/>
<code>
frame.origin.x = position.x - anchorPoint.x * bounds.size.width；  
frame.origin.y = position.y - anchorPoint.y * bounds.size.height；
</code></p>

<p>第2条的互不影响原则还可以这样理解：position与anchorPoint是处于不同坐标空间中的重合点，修改重合点在一个坐标空间的位置不影响该重合点在另一个坐标空间中的位置。</p>

<h3>后记</h3>

<p>20140323：关于修改anchorPoint为什么会移动layer的位置，在刚才回复finder的评论时想到了一个更好的解释：  <br/>
还是以桌子与白纸为例，如果固定图钉在桌上的位置，也就是positon不变，这个时候图钉处在白纸的不同地方就是不同的anchorPoint，相应地也就是不同的frame。   <br/>
另一方面，如果固定图钉在白纸上的位置（没订在桌子上），不管怎么平移白纸，anchorPoint肯定是不变的，但frame肯定是随之变化的</p>

<h4>参考</h4>

<ul>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreAnimation_guide/CoreAnimationBasics/CoreAnimationBasics.html#//apple_ref/doc/uid/TP40004514-CH2-SW15">Core Animation Programming Guide</a></li>
<li><a href="http://stackoverflow.com/questions/1968017/changing-my-calayers-anchorpoint-moves-the-view">Changing my CALayer&rsquo;s anchorPoint moves the view</a></li>
<li><a href="http://www.cocoachina.com/bbs/simple/?t87118.html">对于anchorPoint的一点理解</a></li>
<li><a href="http://www.dreamingwish.com/dream-2012/coreanimation-programming-guide-10-kvc.html">CoreAnimation编程指南(十)KVC</a></li>
<li><a href="http://www.dreamingwish.com/dream-2012/coreanimation-programming-guide-c-the-geometric-transformation.html">CoreAnimation编程指南(三)几何变换</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[升级iOS7后利用rvictl和wireshark抓包失效?]]></title>
    <link href="http://wonderffee.github.io/blog/2013/10/06/caputure-packets-with-rvictl-and-wireshark-after-updating-to-ios7/"/>
    <updated>2013-10-06T11:31:00+08:00</updated>
    <id>http://wonderffee.github.io/blog/2013/10/06/caputure-packets-with-rvictl-and-wireshark-after-updating-to-ios7</id>
    <content type="html"><![CDATA[<p>最近把一台设备升级到iOS7后，利用rvictl和wireshark抓包发现抓不了，无意中发现在装有xcode5的机器上可以抓包，看来rvictl与xcode是绑定的，升级到最新的iOS7后，必须要装上最新的xcode5版本才能抓包。</p>

<p>使用rvictl有一个前提是要获取设备的UDID，看网上不少教程都是从xcode中获取UDID，步骤相当繁琐，快速获取UDID用命令行才是王道，果然不出所料，很快就找到了三种命令行快速得到iOS设备的UDID方法，如下：</p>

<!--more-->


<p>方法1：速度最快
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>ioreg -w 0 -rc IOUSBDevice -k SupportsIPhoneOS | sed -n &amp;rsquo;s/.&lt;em&gt;USB Serial Number<span class="o">[</span>^0-9a-z<span class="o">]</span>&lt;/em&gt;<span class="o">([</span>0-9a-z<span class="o">]</span>&lt;em&gt;<span class="o">)</span>.&lt;/em&gt;/<span class="se">\1</span>/p<span class="err">&#39;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>方法2：不知道为什么不起作用了，因为iOS7的缘故？
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>system_profiler SPUSBDataType | sed -n -e &amp;lsquo;/iPhone/,/Serial/p&amp;rsquo; | grep &amp;ldquo;Serial Number:&amp;rdquo; | awk -F &amp;ldquo;: &amp;rdquo; &amp;lsquo;<span class="o">{</span>print <span class="nv">$2</span><span class="o">}</span>&amp;rsquo;
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>方法3:
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>system_profiler SPUSBDataType | grep &amp;ldquo;Serial Number:.&lt;em&gt;&amp;rdquo; | sed s#&amp;ldquo;.&lt;/em&gt;Serial Number: &amp;rdquo;##
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>不过注意的是，用上面的命令得到的UDID并不一定是唯一的，比如我在MacBook Pro上就得不到唯一的UDID。</p>

<p>以下转载一下用rvictl和wireshark进行抓包的方法：</p>

<p>RVI(Remote Virtual Interface）是在iOS5中开始添加的，利用这个工具，在不需要开代理，也不需要越狱的情况下就可以抓到iOS设备上所有的包，所需要的一台装有Mac OS X的电脑以及USB数据线。我发现Android还没有类似的工具，iOS在这方面就方便多了。</p>

<p>基本的方法就是把设备通过USB连上mac上。然后为这台设备安装RVI，这个虚拟的在Mac上的网卡，就代表这台ios设备的使用网卡。然后在mac上跑抓包的工具，定位到这个虚拟的网卡上，来抓包。</p>

<p>(1)安装RVI，需要使用rvictl工具，以下步骤在mac的终端中操作：  <br/>
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span><span class="c"># First get the current list of interfaces.</span>
</span><span class='line'><span class="nv">$ </span>ifconfig -l
</span><span class='line'>lo0 gif0 stf0 en0 en1 p2p0 fw0 ppp0 utun0
</span><span class='line'><span class="nv">$ </span><span class="c"># Then run the tool with the UDID of the device.&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'>&lt;p&gt;<span class="nv">$ </span>rvictl -s 74bd53c647548234ddcef0ee3abee616005051ed
</span><span class='line'>Starting device 74bd53c647548234ddcef0ee3abee616005051ed <span class="o">[</span>SUCCEEDED<span class="o">]</span>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;<span class="nv">$ </span><span class="c"># Get the list of interfaces again, and you can see the new virtual</span>
</span><span class='line'><span class="nv">$ </span><span class="c"># network interface, rvi0, added by the previous command.</span>
</span><span class='line'><span class="nv">$ </span>ifconfig -l
</span><span class='line'>lo0 gif0 stf0 en0 en1 p2p0 fw0 ppp0 utun0 rvi0
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>(2)安装成功后，此时其实可以用任何抓包工具来抓取。包括wireshark等。因为这时就会看到一个rvi0的网卡。不过今天我们介绍的是通过tcpdump来搞。</p>

<p>在终端中输入如下命令：
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>sudo tcpdump -i rvi0 -n -s 0 -w dump.pcap tcp
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>解释一下上面重要参数的含义：</p>

<p>-i rvi0 选择需要抓取的接口为rvi0（远程虚拟接口）  <br/>
-s 0 抓取全部数据包  <br/>
-w dump.pcap 设置保存的文件名称  <br/>
tcp 只抓取tcp包</p>

<p>当tcpdump运行之后，你可以在iOS设备上开始浏览你想抓取的App，期间产生的数据包均会保存到dump.pcap文件中，当想结束抓取时直接终止tcpdump即可。然后在mac中找到dump.pcap文件。用wireshark打开就ok。</p>

<p>(3)去掉RVI这个虚拟网卡，使用下面的命令： <br/>
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>rvictl -x 74bd53c647548234ddcef0ee3abee616005051ed  &lt;br/&gt;
</span><span class='line'>Stopping device 74bd53c647548234ddcef0ee3abee616005051ed <span class="o">[</span>SUCCEEDED<span class="o">]</span> &lt;br/&gt;
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>整个流程就是这样的。自己动手操作一下吧。。</p>

<p>再详细的细节，请找一下苹果官方的资料：Technical Q&amp;A QA1176。</p>

<p>参考链接：  <br/>
<a href="http://blog.csdn.net/hursing/article/details/8688868">Mac上命令行获取iPhone/iPad的Identifier（UUID） 的方法</a>  <br/>
<a href="http://b.imi.im/post/121">一行命令 得到iOS设备的UDID</a>  <br/>
<a href="http://fanliugen.com/?p=351">未越狱ios设备的抓包方法</a></p>
]]></content>
  </entry>
  
</feed>
